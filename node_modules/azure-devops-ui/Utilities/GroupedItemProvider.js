import { ObservableArray } from '../Core/Observable';
var GroupedItemProvider = /** @class */ (function () {
    /**
     * Create a Provider that arranges IListBoxItems by their groupId.
     * @param initialItems The initial set of items.  Items will be arranged in group order,
     * and dividers and headers will be moved to the top of each group.
     * @param initialGroups The initial set of groups.  Items will be arranged in the order specified by this set.
     * @param manageHeaders Set to true to have the provider create headers and dividers for groups that don't already have them.
     * Headers created this way will have text matching the group's name.
     */
    function GroupedItemProvider(initialItems, initialGroups, manageHeaders) {
        this.listItems = new ObservableArray();
        this.internalGroups = initialGroups.slice();
        // Initialize with one array for the unassigned group.
        this.groupedItems = [[]];
        for (var i = 0; i < this.internalGroups.length; i++) {
            this.groupedItems.push([]);
        }
        this.addItems(initialItems);
        if (manageHeaders) {
            // Add headers and didviders to groups that don't already have them.
            this.addHeaders(1, this.groups.length);
        }
        this.manageHeaders = !!manageHeaders;
    }
    Object.defineProperty(GroupedItemProvider.prototype, "groups", {
        /**
         * Get the internal array of groups.
         */
        get: function () {
            return this.internalGroups;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GroupedItemProvider.prototype, "length", {
        /**
         * Get the length of the listItems array.
         */
        get: function () {
            return this.listItems.length;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GroupedItemProvider.prototype, "value", {
        /**
         * Get the interal array of listItems.
         */
        get: function () {
            return this.listItems.value;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Subscribe to changes in the underlying set of items.
     * @param observer the delegate to be called when there are updates.
     * @param action the action on the set to observe.
     */
    GroupedItemProvider.prototype.subscribe = function (observer, action) {
        this.listItems.subscribe(observer, action);
    };
    /**
     * Unsubscribe from changes in the underlying set of items.
     * @param observer the delegate that was used to subscribe.
     * @param action the action that was used to subsribe.
     */
    GroupedItemProvider.prototype.unsubscribe = function (observer, action) {
        return this.listItems.unsubscribe(observer, action);
    };
    /**
     * Add items to the end of whichever group they belong to.
     * @param items a list of items to add.
     */
    GroupedItemProvider.prototype.push = function () {
        var items = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            items[_i] = arguments[_i];
        }
        this.addItems(items);
        return items.length;
    };
    /**
     * Add groups to the end of the group list.  If there are items with these group id's already in the
     * item set they will arrange into these new groups.
     * @param groups
     */
    GroupedItemProvider.prototype.pushGroups = function () {
        var groups = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            groups[_i] = arguments[_i];
        }
        this.addGroups.apply(this, [this.internalGroups.length].concat(groups));
        return this.internalGroups.length;
    };
    /**
     * Remove the last item in the item set and return it.
     */
    GroupedItemProvider.prototype.pop = function () {
        var removedItem = this.listItems.pop();
        if (removedItem) {
            this.removeItems([removedItem]);
        }
        return removedItem;
    };
    /**
     * Remove all items that match the given filter.
     * @param filter the filter function to run on all items.  If this returns true, the item will be deleted.
     */
    GroupedItemProvider.prototype.removeAll = function (filter) {
        var removedItems = this.listItems.removeAll(filter);
        this.removeItems(removedItems);
        return removedItems;
    };
    /**
     * Remove and add items from a provided index.  Added items will be arranged by their groupId.
     * @param start the index to start insertion and deletion.
     * @param deleteCount the number of items to delete.
     * @param itemsToAdd the items to insert at the start index.
     */
    GroupedItemProvider.prototype.splice = function (start, deleteCount) {
        var itemsToAdd = [];
        for (var _i = 2; _i < arguments.length; _i++) {
            itemsToAdd[_i - 2] = arguments[_i];
        }
        var removedItems = this.listItems.splice(start, deleteCount);
        this.removeItems(removedItems, false);
        this.addItems(itemsToAdd);
        return removedItems;
    };
    /**
     * Remove and add groups from a provided index.  All items in deletes groups will be removed from the item set.
     * @param start the index to start insertion and deletion.
     * @param deleteCount the number of groups to delete.
     * @param groupsToAdd the groups to insert at the start index.
     */
    GroupedItemProvider.prototype.spliceGroups = function (start, deleteCount) {
        var groupsToAdd = [];
        for (var _i = 2; _i < arguments.length; _i++) {
            groupsToAdd[_i - 2] = arguments[_i];
        }
        for (var i = 0; i < deleteCount; i++) {
            var groupIndex = start + i + 1;
            if (this.groupedItems.length > groupIndex) {
                this.removeItems(this.groupedItems[groupIndex].slice());
                if (this.manageHeaders) {
                    // If we deleted the top group, remove the border from the next group.
                    if (groupIndex === 1 && !this.groupedItems[0].length && this.groupedItems.length > 2) {
                        var extraDivider = this.groupedItems[2].find(function (item) { return item.type === 3 /* Divider */; });
                        if (extraDivider) {
                            this.removeItems([extraDivider]);
                        }
                    }
                }
                this.groupedItems.splice(groupIndex, 1);
            }
        }
        var deletedGroups = this.internalGroups.splice(start, deleteCount);
        this.addGroups.apply(this, [start].concat(groupsToAdd));
        return deletedGroups;
    };
    /**
     * Add headers and didvers to groups that don't already have them.
     * @param start the groupMap index to add header/dividers to.
     * This is 1 more than the internalGroup index since there is an unassigned group at index 0.
     * @param count the number of groups that are new and may need headers.
     */
    GroupedItemProvider.prototype.addHeaders = function (start, count) {
        for (var i = 0; i < count; i++) {
            var group = this.groups[i + start - 1];
            if (!this.groupedItems[i + start].find(function (item) { return item.type === 2 /* Header */; })) {
                this.addItems([{ id: group.id + "-header", text: group.name, type: 2 /* Header */, groupId: group.id }]);
            }
            if ((start + i > 1 || this.groupedItems[0].length) && !this.groupedItems[i + start].find(function (item) { return item.type === 3 /* Divider */; })) {
                this.addItems([{ id: group.id + "-divider", type: 3 /* Divider */, groupId: group.id }]);
            }
            // If a group is being added to the beginning, and the second group doesn't have a divider, add one.
            if (start + i === 1 && this.groups.length > 1 && !this.groupedItems[2].find(function (item) { return item.type === 3 /* Divider */; })) {
                group = this.groups[1];
                this.addItems([{ id: group.id + "-divider", type: 3 /* Divider */, groupId: group.id }]);
            }
        }
    };
    /**
     * Add groups to the internal list of groups.  Items from the unsassigned group will be moved to the new groups
     * If they have a matching groupId.
     * @param index the index to add the groups at.
     * @param groups the groups to add.
     */
    GroupedItemProvider.prototype.addGroups = function (index) {
        var _a;
        var groups = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            groups[_i - 1] = arguments[_i];
        }
        (_a = this.internalGroups).splice.apply(_a, [index, 0].concat(groups));
        var unassignedItemsToAdd = [];
        for (var i = 0; i < groups.length; i++) {
            this.groupedItems.splice(index + i + 1, 0, []);
            // Move all items from the unassigned group to the new group if they have a matching groupId.
            for (var j = 0; j < this.groupedItems[0].length; j++) {
                if (this.groupedItems[0][j].groupId === groups[i].id) {
                    var unassignedItemToAdd = this.groupedItems[0].splice(j, 1)[0];
                    this.listItems.splice(j, 1);
                    unassignedItemsToAdd.push(unassignedItemToAdd);
                }
            }
        }
        this.addItems(unassignedItemsToAdd);
        if (this.manageHeaders) {
            this.addHeaders(index + 1, groups.length);
        }
    };
    /**
     * Add items to the item set, arranging them according to their groupId.
     * @param items the items to add.
     */
    GroupedItemProvider.prototype.addItems = function (items) {
        var _loop_1 = function (i) {
            var groupIndex = 0;
            var newItemIndex = 0;
            var groupId = items[i].groupId;
            if (groupId !== undefined) {
                groupIndex = this_1.internalGroups.findIndex(function (group) { return group.id === groupId; }) + 1;
            }
            for (var j = 0; j < groupIndex; j++) {
                newItemIndex += this_1.groupedItems[j].length;
            }
            // Put dividers at the top, followed by headers.
            if (items[i].type === 3 /* Divider */) {
                this_1.groupedItems[groupIndex].unshift(items[i]);
            }
            else if (items[i].type === 2 /* Header */) {
                if (this_1.groupedItems[groupIndex].length && this_1.groupedItems[groupIndex][0].type === 3 /* Divider */) {
                    this_1.groupedItems[groupIndex].splice(1, 0, items[i]);
                    newItemIndex++;
                }
                else {
                    this_1.groupedItems[groupIndex].unshift(items[i]);
                }
            }
            else {
                newItemIndex += this_1.groupedItems[groupIndex].length;
                this_1.groupedItems[groupIndex].push(items[i]);
            }
            this_1.listItems.splice(newItemIndex, 0, items[i]);
        };
        var this_1 = this;
        for (var i = 0; i < items.length; i++) {
            _loop_1(i);
        }
    };
    /**
     * Removed items from the internal groupedItems lists and optionally from the actual list of items.
     * @param items the items to remove.
     * @param removeFromListItems Whether or not to remove the items from the list of items.
     */
    GroupedItemProvider.prototype.removeItems = function (items, removeFromListItems) {
        if (removeFromListItems === void 0) { removeFromListItems = true; }
        var _loop_2 = function (i) {
            var groupIndex = 0;
            var itemIndex = 0;
            var groupId = items[i].groupId;
            if (groupId !== undefined) {
                groupIndex = this_2.internalGroups.findIndex(function (group) { return group.id === groupId; }) + 1;
            }
            for (var j = 0; j < groupIndex; j++) {
                itemIndex += this_2.groupedItems[j].length;
            }
            var group = this_2.groupedItems[groupIndex];
            var indexInGroup = group.indexOf(items[i]);
            group.splice(indexInGroup, 1);
            if (removeFromListItems) {
                this_2.listItems.splice(itemIndex + indexInGroup, 1);
            }
        };
        var this_2 = this;
        for (var i = 0; i < items.length; i++) {
            _loop_2(i);
        }
    };
    return GroupedItemProvider;
}());
export { GroupedItemProvider };
