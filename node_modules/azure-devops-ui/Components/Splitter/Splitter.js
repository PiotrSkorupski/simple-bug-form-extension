import * as tslib_1 from "tslib";
import "../../CommonImports";
import "../../Core/core.css";
import "./Splitter.css";
import * as React from "react";
import { EventManagement } from '../../Core/EventManagement';
import { css } from '../../Util';
var DIVIDER_MOVE_INCREMENT = 20;
var DIVIDER_WIDTH = 4;
var Splitter = /** @class */ (function (_super) {
    tslib_1.__extends(Splitter, _super);
    function Splitter(props, context) {
        var _this = _super.call(this, props, context) || this;
        /**
         *  Keyboard handler for the divider
         */
        _this._onDividerKeyDown = function (event) {
            var _a = _this.props, disabled = _a.disabled, splitterDirection = _a.splitterDirection;
            if (!disabled && !_this._isDragging) {
                switch (event.keyCode) {
                    case 37 /* leftArrow */:
                        if (splitterDirection === 0 /* Vertical */) {
                            _this._moveDivider(0 /* Near */);
                        }
                        break;
                    case 39 /* rightArrow */:
                        if (splitterDirection === 0 /* Vertical */) {
                            _this._moveDivider(1 /* Far */);
                        }
                        break;
                    case 38 /* upArrow */:
                        if (splitterDirection === 1 /* Horizontal */) {
                            _this._moveDivider(0 /* Near */);
                        }
                        break;
                    case 40 /* downArrow */:
                        if (splitterDirection === 1 /* Horizontal */) {
                            _this._moveDivider(1 /* Far */);
                        }
                        break;
                    default:
                        return;
                }
                event.preventDefault();
                event.stopPropagation();
            }
        };
        /**
         * Fired when the user mouses down on the divider
         * If there is a fixed pane, records its initial size, and attaches mouse move and mouse up events to the window
         */
        _this._onDividerMouseDown = function (event) {
            var disabled = _this.props.disabled;
            var fixedSize = _this.state.fixedSize;
            if (_this._fixedRef && !disabled) {
                event.preventDefault();
                event.stopPropagation();
                _this._dragAnchorPos = _this._getEventBoundedClientPos(event);
                _this._previousFixedSize = _this._getElementSize(_this._fixedRef);
                var newWidth = _this._getNewFixedSize(_this._previousFixedSize, _this._dragAnchorPos);
                // Reset placeholderX and gridWidth in case the window has been resized
                if (fixedSize !== newWidth) {
                    _this.setState({
                        placeholderPosition: undefined,
                        fixedSize: newWidth
                    });
                }
                _this._attachWindowEvents();
                _this._handleDragMouseEvent(event);
            }
        };
        /**
         * Fired when the user moves their mouse, after having moused down on the divider
         * Computes the new location of the placeholder
         * @param event
         */
        _this._onDividerMouseMove = function (event) {
            _this._handleDragMouseEvent(event);
        };
        /**
         * Fired when the user releases their mouse, after having moused down on the divider
         * Updates the size of the fixed pane, and stops the drag
         * Removes window events
         */
        _this._onDividerMouseUp = function (event) {
            _this._detachWindowEvents();
            var boundedClientPos = _this._getEventBoundedClientPos(event);
            var newSize = _this._getNewFixedSize(_this._previousFixedSize, _this._dragAnchorPos, boundedClientPos);
            _this.setState({ placeholderPosition: undefined });
            _this._setFixedSize(newSize);
            _this._fireWindowResize();
        };
        _this.events = new EventManagement();
        _this.state = {
            fixedSize: props.fixedSize || props.initialFixedSize,
            placeholderPosition: undefined,
            showDivider: _this._shouldShowDivider(props)
        };
        return _this;
    }
    Splitter.prototype.componentWillReceiveProps = function (nextProps) {
        var shouldShowDivider = this._shouldShowDivider(nextProps);
        if (shouldShowDivider !== this.state.showDivider) {
            this.setState({ showDivider: shouldShowDivider });
        }
        if (this.props.fixedSize !== nextProps.fixedSize) {
            if (nextProps.fixedSize != null) {
                // If the passed in fixedSize is updated, update the state
                this.setState({ fixedSize: this._getNewFixedSize(nextProps.fixedSize, 0, 0, nextProps) });
            }
            else if (this.props.fixedSize != null) {
                // We are switching to an uncontrolled mode, set the fixed size to the previous known value and print a warning
                this.setState({ fixedSize: this._getNewFixedSize(this.props.fixedSize, 0, 0, nextProps) });
                if ($DEBUG) {
                    console.warn("Splitter: Splitter is switching from controlled mode to uncontrolled mode. You should not switched from a controlled to uncontrolled mode. Using the previous available size");
                }
            }
        }
        else if (this.props.splitterDirection !== nextProps.splitterDirection ||
            this.props.minFixedSize !== nextProps.minFixedSize ||
            this.props.maxFixedSize !== nextProps.maxFixedSize) {
            // If certain dimensions have changed, update the fixed size so it remains in bounds
            this.setState({ fixedSize: this._getNewFixedSize(this.state.fixedSize, 0, 0, nextProps) });
        }
    };
    Splitter.prototype.componentDidMount = function () {
        this._fireWindowResize();
    };
    Splitter.prototype.componentWillUnmount = function () {
        this.events.removeAllListeners();
    };
    Splitter.prototype.render = function () {
        var _this = this;
        var _a = this.props, className = _a.className, splitterDirection = _a.splitterDirection;
        return (React.createElement("div", { className: css(className, "vss-Splitter--container", splitterDirection === 0 /* Vertical */ && "vss-Splitter--container-row", splitterDirection === 1 /* Horizontal */ && "vss-Splitter--container-column", this._isDragging && "vss-Splitter--container-dragging"), ref: function (splitterContainer) { return (_this._splitterContainer = splitterContainer); } },
            this._renderNearElement(),
            this._renderDivider(),
            this._renderDragPlaceHolder(),
            this._renderFarElement()));
    };
    /**
     *  Renders the first child
     */
    Splitter.prototype._renderNearElement = function () {
        var _a = this.props, fixedElement = _a.fixedElement, onRenderNearElement = _a.onRenderNearElement, nearElementClassName = _a.nearElementClassName;
        if (this._isDragging && this._cachedNearElement) {
            return this._cachedNearElement;
        }
        this._cachedNearElement = null;
        if (onRenderNearElement) {
            var content = onRenderNearElement();
            this._cachedNearElement =
                fixedElement === 0 /* Near */
                    ? this._renderFixedPane(content, nearElementClassName)
                    : this._renderFlexiblePane(content, nearElementClassName);
            return this._cachedNearElement;
        }
    };
    /**
     *  Renders the last child. If there are 0-1 children, will render a flexible pane
     */
    Splitter.prototype._renderFarElement = function () {
        var _a = this.props, fixedElement = _a.fixedElement, onRenderFarElement = _a.onRenderFarElement, farElementClassName = _a.farElementClassName;
        if (this._isDragging && this._cachedFarElement) {
            return this._cachedFarElement;
        }
        this._cachedFarElement = null;
        if (onRenderFarElement) {
            var content = onRenderFarElement();
            this._cachedFarElement =
                fixedElement === 1 /* Far */
                    ? this._renderFixedPane(content, farElementClassName)
                    : this._renderFlexiblePane(content, farElementClassName);
            return this._cachedFarElement;
        }
    };
    /**
     *  Render the fixed pane, with size determined by state
     */
    Splitter.prototype._renderFixedPane = function (content, className) {
        var _this = this;
        var _a = this.props, minFixedSize = _a.minFixedSize, maxFixedSize = _a.maxFixedSize, splitterDirection = _a.splitterDirection;
        var fixedSize = this.state.fixedSize;
        var size;
        if (fixedSize) {
            size = fixedSize;
        }
        else {
            if (minFixedSize != null) {
                size = minFixedSize;
            }
            else if (maxFixedSize != null) {
                size = maxFixedSize;
            }
            else {
                size = "50%";
            }
        }
        var dividerStyle = splitterDirection === 0 /* Vertical */
            ? {
                width: size
            }
            : {
                height: size
            };
        if (content) {
            return (React.createElement("div", { className: css("vss-Splitter--pane-fixed", className), style: dividerStyle, ref: function (fixedRef) { return (_this._fixedRef = fixedRef); } }, content));
        }
    };
    /**
     *  Render the flexible pane
     */
    Splitter.prototype._renderFlexiblePane = function (content, className) {
        return React.createElement("div", { className: css("vss-Splitter--pane-flexible", className) }, content);
    };
    /**
     *  Render the divider
     */
    Splitter.prototype._renderDivider = function () {
        var _a = this.props, fixedElement = _a.fixedElement, minFixedSize = _a.minFixedSize, maxFixedSize = _a.maxFixedSize;
        var _b = this.state, fixedSize = _b.fixedSize, showDivider = _b.showDivider;
        if (!showDivider) {
            return null;
        }
        var _c = this._getSplitterBoundaries(), startBound = _c.startBound, endBound = _c.endBound;
        return (React.createElement("div", { "aria-valuemin": startBound, "aria-valuemax": endBound, "aria-valuenow": fixedSize, role: "separator", tabIndex: 0, className: css("vss-Splitter--divider", this._isDragging && "vss-Splitter--divider-dragging"), onKeyDown: this._onDividerKeyDown, onMouseDown: this._onDividerMouseDown }));
    };
    /**
     *  Render the placeholder if the user is dragging
     */
    Splitter.prototype._renderDragPlaceHolder = function () {
        var splitterDirection = this.props.splitterDirection;
        var placeholderPosition = this.state.placeholderPosition;
        var placeholderStyle = splitterDirection === 0 /* Vertical */
            ? {
                left: placeholderPosition
            }
            : {
                top: placeholderPosition
            };
        if (this._isDragging) {
            return React.createElement("div", { className: "vss-Splitter--drag-placeholder", style: placeholderStyle });
        }
    };
    /**
     * Computes the new location of the placeholder based on the mouse event.
     * @param event
     */
    Splitter.prototype._handleDragMouseEvent = function (event) {
        var fixedElement = this.props.fixedElement;
        var placeholderPosition = this.state.placeholderPosition;
        event.preventDefault();
        event.stopPropagation();
        var boundedClientPos = this._getEventBoundedClientPos(event);
        var newSize = this._getNewFixedSize(this._previousFixedSize, this._dragAnchorPos, boundedClientPos);
        if (newSize !== placeholderPosition) {
            this.setState({
                placeholderPosition: fixedElement === 0 /* Near */ ? newSize : this._getElementSize(this._splitterContainer) - newSize - DIVIDER_WIDTH
            });
        }
    };
    Splitter.prototype._setFixedSize = function (newFixedSize) {
        var _a = this.props, fixedSize = _a.fixedSize, onFixedSizeChanged = _a.onFixedSizeChanged;
        // We are in uncontrolled mode, set the state
        // Otherwise, we must wait for a new state to be passed in
        if (fixedSize == null) {
            this.setState({
                fixedSize: newFixedSize
            });
        }
        if (onFixedSizeChanged) {
            onFixedSizeChanged(newFixedSize);
        }
    };
    /**
     * Move the divider in a near or far direction
     * @param direction The Direction
     */
    Splitter.prototype._moveDivider = function (direction) {
        var currentSize = this._getElementSize(this._fixedRef);
        var newSize;
        switch (direction) {
            case 0 /* Near */:
                newSize = this._getNewFixedSize(currentSize, DIVIDER_MOVE_INCREMENT, 0);
                break;
            case 1 /* Far */:
                newSize = this._getNewFixedSize(currentSize, 0, DIVIDER_MOVE_INCREMENT);
                break;
            default:
                return;
        }
        this._setFixedSize(newSize);
        this._fireWindowResize();
    };
    /** Attaches mouse events to the window */
    Splitter.prototype._attachWindowEvents = function () {
        this.events.addEventListener(window, "mousemove", this._onDividerMouseMove);
        this.events.addEventListener(window, "mouseup", this._onDividerMouseUp);
    };
    /** Detaches mouse events to the window */
    Splitter.prototype._detachWindowEvents = function () {
        this.events.removeEventListener(window, "mousemove", this._onDividerMouseMove);
        this.events.removeEventListener(window, "mouseup", this._onDividerMouseUp);
    };
    /**
     * Get a X/Y position of a mouse event, relative to the splitter container and depending on the splitter direction
     * The position will be bounded within the splitter container and the min/max widths of the fixed panel
     * @param event
     */
    Splitter.prototype._getEventBoundedClientPos = function (event) {
        var splitterDirection = this.props.splitterDirection;
        var clientPos;
        switch (splitterDirection) {
            case 0 /* Vertical */:
                clientPos = event.clientX;
                break;
            case 1 /* Horizontal */:
                clientPos = event.clientY;
                break;
            default:
                clientPos = 0;
        }
        return this._getBoundedClientPos(clientPos);
    };
    /**
     * Given a position relative to the window, get a position relative to the splitter container and depending on the splitter direction
     * The position will be bounded within the splitter container and the min/max widths of the fixed panel
     * @param clientPos The position relative to the window
     * @param props The props to use
     */
    Splitter.prototype._getBoundedClientPos = function (clientPos, props) {
        if (props === void 0) { props = this.props; }
        var fixedElement = props.fixedElement, minFixedSize = props.minFixedSize, maxFixedSize = props.maxFixedSize;
        var _a = this._getSplitterBoundaries(), startBound = _a.startBound, endBound = _a.endBound;
        var boundedClientPos = Math.max(
        // Smallest allowed client pos start
        startBound, 
        // Largest allowed client pos end
        Math.min(clientPos, endBound));
        // Adjust relative to the container
        return boundedClientPos - this._getElementStartPos(this._splitterContainer, props);
    };
    /**
     * Compute the allowable pixel value bounds for the splitter
     * @param props The props to use
     */
    Splitter.prototype._getSplitterBoundaries = function (props) {
        if (props === void 0) { props = this.props; }
        var fixedElement = props.fixedElement, minFixedSize = props.minFixedSize, maxFixedSize = props.maxFixedSize;
        if (!this._splitterContainer) {
            return { startBound: 0, endBound: 0 };
        }
        var startPos = this._getElementStartPos(this._splitterContainer, props);
        var size = this._getElementSize(this._splitterContainer, props);
        var endPos = startPos + size;
        var startBound = fixedElement === 0 /* Near */
            ? minFixedSize
                ? startPos + minFixedSize
                : startPos
            : maxFixedSize
                ? endPos - maxFixedSize
                : startPos;
        var endBound = fixedElement === 0 /* Near */
            ? maxFixedSize
                ? startPos + maxFixedSize
                : endPos
            : minFixedSize
                ? endPos - minFixedSize
                : endPos;
        return { startBound: startBound, endBound: endBound };
    };
    /**
     * Gets a new width from an anchor, an initial width, and a drag delta
     * @param initialSize The initial width
     * @param anchor The drag anchor
     * @param newPosition The new drag X value
     */
    Splitter.prototype._getNewFixedSize = function (initialSize, anchor, newPosition, props) {
        if (newPosition === void 0) { newPosition = anchor; }
        if (props === void 0) { props = this.props; }
        var fixedElement = props.fixedElement, _a = props.minFixedSize, minFixedSize = _a === void 0 ? 0 : _a, _b = props.maxFixedSize, maxFixedSize = _b === void 0 ? this._getElementSize(this._splitterContainer) : _b;
        var posDiff = newPosition - anchor;
        if (fixedElement === 1 /* Far */) {
            posDiff *= -1;
        }
        var newSize = initialSize + posDiff;
        return Math.max(minFixedSize, Math.min(maxFixedSize, newSize));
    };
    Object.defineProperty(Splitter.prototype, "_isDragging", {
        /**
         * Indicates if a drag operation is in process
         */
        get: function () {
            var placeholderPosition = this.state.placeholderPosition;
            return placeholderPosition != null;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Get the size (width or height) of an element, based on the splitter direction
     * @param element The element
     */
    Splitter.prototype._getElementSize = function (element, props) {
        if (props === void 0) { props = this.props; }
        var splitterDirection = props.splitterDirection;
        switch (splitterDirection) {
            case 0 /* Vertical */:
                return element.clientWidth;
            case 1 /* Horizontal */:
                return element.clientHeight;
            default:
                return 0;
        }
    };
    /**
     * Get the start position (left or top) of an element, based on the splitter direction
     * @param element The element
     */
    Splitter.prototype._getElementStartPos = function (element, props) {
        if (props === void 0) { props = this.props; }
        var splitterDirection = props.splitterDirection;
        var boundingRect = element.getBoundingClientRect();
        switch (splitterDirection) {
            case 0 /* Vertical */:
                return boundingRect.left;
            case 1 /* Horizontal */:
                return boundingRect.top;
            default:
                return 0;
        }
    };
    Splitter.prototype._shouldShowDivider = function (props) {
        var onRenderFarElement = props.onRenderFarElement, onRenderNearElement = props.onRenderNearElement, fixedElement = props.fixedElement;
        switch (fixedElement) {
            case 0 /* Near */:
                return !!onRenderNearElement;
            case 1 /* Far */:
                return !!onRenderFarElement;
        }
    };
    Splitter.prototype._fireWindowResize = function () {
        var event = document.createEvent("Event");
        event.initEvent("resize", false, true);
        window.dispatchEvent(event);
    };
    Splitter.defaultProps = {
        fixedElement: 1 /* Far */,
        splitterDirection: 0 /* Vertical */
    };
    return Splitter;
}(React.Component));
export { Splitter };
