import * as tslib_1 from "tslib";
import "../../CommonImports";
import "../../Core/core.css";
import "./Tooltip.css";
import * as React from "react";
import { Callout } from '../../Callout';
import { FocusWithin } from '../../FocusWithin';
import { css, getFocusVisible, getSafeId, Mouse } from '../../Util';
var Tooltip = /** @class */ (function (_super) {
    tslib_1.__extends(Tooltip, _super);
    function Tooltip(props) {
        var _this = _super.call(this, props) || this;
        _this.openTimeout = -1;
        _this.onBlur = function () {
            _this.setState({ focus: false });
            if (_this.existingBlur) {
                _this.existingBlur();
            }
        };
        _this.onFocus = function (event) {
            _this.setState({
                anchorElement: event.target,
                anchorOffset: { horizontal: 0, vertical: 8 },
                anchorOrigin: { horizontal: "center" /* center */, vertical: "end" /* end */ },
                anchorPoint: undefined,
                focus: true,
                tooltipOrigin: { horizontal: "center" /* center */, vertical: "start" /* start */ }
            });
            if (_this.existingFocus) {
                _this.existingFocus(event);
            }
        };
        _this.onMouseEnter = function (event) {
            if (!_this.props.disabled) {
                var anchorElement_1 = event.currentTarget;
                // If the tooltip only appears when the anchorElement overflows its parent then
                // we need to check on mouse enter.
                if (_this.props.overflowOnly) {
                    if (anchorElement_1.scrollWidth <= Math.ceil(anchorElement_1.offsetWidth)) {
                        return;
                    }
                }
                // Dont show the tooltip if there is not content to show.
                if (_this.props.text || _this.props.renderContent || (anchorElement_1.innerText && _this.props.overflowOnly)) {
                    if (_this.openTimeout === -1) {
                        _this.openTimeout = window.setTimeout(function () {
                            _this.openTimeout = -1;
                            // If no anchorOrigin was specified use the Mouse.position when we show the toolip.
                            var anchorPoint;
                            if (!_this.props.anchorOrigin) {
                                anchorPoint = Mouse.position;
                            }
                            _this.setState({
                                anchorElement: anchorElement_1,
                                anchorOffset: { horizontal: 8, vertical: 8 },
                                anchorOrigin: { horizontal: "center" /* center */, vertical: "end" /* end */ },
                                anchorPoint: anchorPoint,
                                innerText: _this.props.overflowOnly && !_this.props.text ? anchorElement_1.innerText : undefined,
                                mouse: true,
                                tooltipOrigin: { horizontal: "start" /* start */, vertical: "start" /* start */ }
                            });
                        }, _this.props.delayMs);
                    }
                }
            }
            if (_this.existingMouseEnter) {
                _this.existingMouseEnter(event);
            }
        };
        _this.onMouseLeave = function (event) {
            if (_this.openTimeout !== -1) {
                window.clearTimeout(_this.openTimeout);
                _this.openTimeout = -1;
            }
            if (_this.state.mouse) {
                _this.setState({ mouse: false });
            }
            if (_this.existingMouseLeave) {
                _this.existingMouseLeave(event);
            }
        };
        _this.state = {
            focus: false,
            mouse: false
        };
        return _this;
    }
    Tooltip.prototype.render = function () {
        var child = React.Children.only(this.props.children);
        // Save the existing events we will potentially proxy.
        this.existingMouseEnter = child.props.onMouseEnter;
        this.existingMouseLeave = child.props.onMouseLeave;
        // to not let consumers have to care about an implementation detail, wrap
        // the tooltip id in getSafeId and use that as the aria-describedBy property
        // on the child.
        var ariaDescribedById = this.props.addAriaDescribedBy ? getSafeId(this.props.id) : undefined;
        var clonedChild = React.cloneElement(child, Object.assign({}, { "aria-describedby": ariaDescribedById }, child.props, {
            onMouseEnter: this.onMouseEnter,
            onMouseLeave: this.onMouseLeave
        }), child.props.children);
        // If this tooltip should become visible when focus is within the component add the focus tracking.
        if (this.props.showOnFocus && (this.props.text || this.props.renderContent)) {
            this.existingBlur = child.props.onBlur;
            this.existingFocus = child.props.onFocus;
            clonedChild = (React.createElement(FocusWithin, { onBlur: this.onBlur, onFocus: this.onFocus, updateStateOnFocusChange: false }, clonedChild));
        }
        return (React.createElement(React.Fragment, null,
            clonedChild,
            (this.state.mouse || (this.state.focus && getFocusVisible())) && !this.props.disabled && this.state.anchorElement ? (React.createElement(Callout, { anchorElement: this.state.anchorElement, anchorOffset: this.props.anchorOffset || this.state.anchorOffset, anchorOrigin: this.props.anchorOrigin || this.state.anchorOrigin, anchorPoint: this.state.anchorPoint, calloutOrigin: this.props.tooltipOrigin || this.state.tooltipOrigin, className: css(this.props.className, "bolt-tooltip"), fixedLayout: this.props.fixedLayout, id: this.props.id, portalProps: { className: "bolt-tooltip-portal" } },
                React.createElement("div", { className: "bolt-tooltip-content" }, (this.props.renderContent && this.props.renderContent()) || this.props.text || this.state.innerText))) : null));
    };
    Tooltip.prototype.componentWillUnmount = function () {
        if (this.openTimeout !== -1) {
            window.clearTimeout(this.openTimeout);
        }
    };
    Tooltip.defaultProps = {
        delayMs: 250
    };
    return Tooltip;
}(React.Component));
export { Tooltip };
