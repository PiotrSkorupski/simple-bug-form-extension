import * as tslib_1 from "tslib";
import "../../CommonImports";
import "../../Core/core.css";
import "./IdentityPickerDropdown.css";
import * as React from "react";
import { ObservableArray, ObservableLike, ObservableValue } from '../../Core/Observable';
import { TimerManagement } from '../../Core/TimerManagement';
import { makeCancelable } from '../../Core/Util/Promise';
import { Icon } from '../../Icon';
import { Observer } from '../../Observer';
import { Persona } from '../../Persona';
import * as Resources from '../../Resources.IdentityPicker';
import { TextField } from '../../TextField';
import { css } from '../../Util';
import { IdentityPickerSuggestionsList } from "../IdentityPickerSuggestionsList/IdentityPickerSuggestionsList";
import { Measure } from '../../Measure';
var CustomIdentityPickerDropdown = /** @class */ (function (_super) {
    tslib_1.__extends(CustomIdentityPickerDropdown, _super);
    function CustomIdentityPickerDropdown(props) {
        var _this = _super.call(this, props) || this;
        _this.hasFocus = new ObservableValue(false);
        _this.inputElement = React.createRef();
        _this.openedIdentityCard = new ObservableValue(undefined);
        _this.outerElement = React.createRef();
        _this.suggestionsLoading = new ObservableValue(false);
        _this.isEditing = new ObservableValue(false);
        _this.selectedIndex = new ObservableValue(-1);
        _this.suggestions = new ObservableArray([]);
        _this.onPickerDismiss = function () {
            _this.props.onSuggestionsVisibleChanged(false);
            if (!_this.hasFocus.value) {
                _this.props.onBlur && _this.props.onBlur();
            }
        };
        _this.renderPersonaCoin = function (className) {
            return (React.createElement(Observer, { selectedIdentity: _this.props.value, isEditing: _this.isEditing }, function (props) {
                return props.selectedIdentity && !props.isEditing ? (React.createElement(Persona, { className: css("flex-row flex-center justify-center", className), identity: props.selectedIdentity, size: 3 /* small */ })) : (React.createElement(Icon, { className: css("bolt-identitypickerdropdown-unknown-icon font-size-ml flex-row flex-center justify-center", className), iconName: "Contact" }));
            }));
        };
        _this.openPersonaCard = function (identity) {
            _this.openedIdentityCard.value = identity;
        };
        _this.closePersonaCard = function () {
            _this.openedIdentityCard.value = undefined;
        };
        _this.completeSuggestion = function () {
            if (_this.suggestions.value.length > 0 && ObservableLike.getValue(_this.props.suggestionsVisible)) {
                if (_this.selectedIndex.value < 0) {
                    _this.selectedIndex.value = 0;
                }
                _this.suggestions.value &&
                    _this.suggestions.value[_this.selectedIndex.value] &&
                    _this.selectedPersonaChanged(_this.suggestions.value[_this.selectedIndex.value]);
                _this.props.onSuggestionsVisibleChanged(false);
            }
            else {
                _this.selectedIndex.value = -1;
                _this.selectedPersonaChanged();
            }
        };
        _this.onBlur = function () {
            _this.hasFocus.value = false;
            _this.timerManagement.setTimeout(function () {
                var areContactOrSuggestionsOpen = !_this.openedIdentityCard.value && !ObservableLike.getValue(_this.props.suggestionsVisible);
                areContactOrSuggestionsOpen && _this.props.onBlur && _this.props.onBlur();
                areContactOrSuggestionsOpen && ObservableLike.getValue(_this.props.textValue) === "" && _this.selectedPersonaChanged();
            }, 100);
        };
        _this.onClearClicked = function (ev) {
            _this.props.onClear && _this.props.onClear();
            _this.props.onChange(undefined);
            _this.lastPickedIdentity = undefined;
            _this.suggestions.value = [];
            ev.preventDefault();
        };
        _this.onClick = function () {
            if (ObservableLike.getValue(_this.props.textValue) === "" && _this.props.pickerProvider.onEmptyInputFocus) {
                _this.updateSuggestionsList(_this.props.pickerProvider.onEmptyInputFocus());
                _this.props.onSuggestionsVisibleChanged(!ObservableLike.getValue(_this.props.suggestionsVisible));
            }
            else {
                _this.props.onSuggestionsVisibleChanged(!ObservableLike.getValue(_this.props.suggestionsVisible));
            }
            _this.inputElement.current.select();
        };
        _this.onFocus = function (e) {
            var onFocus = _this.props.onFocus;
            if (ObservableLike.getValue(_this.props.textValue) === "" &&
                _this.props.pickerProvider.onEmptyInputFocus &&
                !ObservableLike.getValue(_this.props.suggestionsVisible)) {
                _this.updateSuggestionsList(_this.props.pickerProvider.onEmptyInputFocus());
            }
            _this.hasFocus.value = true;
            if (onFocus) {
                onFocus(e);
            }
        };
        _this.onKeyDown = function (ev) {
            if (ev.isDefaultPrevented()) {
                return;
            }
            var keyCode = ev.which;
            var suggestionsVisible = ObservableLike.getValue(_this.props.suggestionsVisible);
            switch (keyCode) {
                case 27 /* escape */:
                    if (_this.openedIdentityCard.value) {
                        !(_this.suggestions.value && _this.suggestions.value[_this.selectedIndex.value]) && _this.selectedPersonaChanged();
                    }
                    if (suggestionsVisible) {
                        _this.props.onSuggestionsVisibleChanged(false);
                        _this.openedIdentityCard.value = undefined;
                    }
                    break;
                case 9 /* tab */:
                case 13 /* enter */:
                    if (!ev.shiftKey && suggestionsVisible) {
                        _this.completeSuggestion();
                        ev.preventDefault();
                        ev.stopPropagation();
                    }
                    else if (suggestionsVisible) {
                        _this.completeSuggestion();
                    }
                    break;
                case 39 /* rightArrow */:
                    if (_this.suggestions.value && _this.suggestions.value[_this.selectedIndex.value]) {
                        _this.openedIdentityCard.value = _this.suggestions.value[_this.selectedIndex.value];
                    }
                    break;
                case 38 /* upArrow */:
                    if (suggestionsVisible && _this.suggestions.value) {
                        _this.selectedIndex.value = Math.max(0, _this.selectedIndex.value - 1);
                        _this.forceUpdate();
                        ev.preventDefault();
                        ev.stopPropagation();
                    }
                    break;
                case 40 /* downArrow */:
                    if (suggestionsVisible && _this.suggestions.value) {
                        _this.selectedIndex.value = Math.min(_this.suggestions.value.length - 1, _this.selectedIndex.value + 1);
                        _this.forceUpdate();
                        ev.preventDefault();
                        ev.stopPropagation();
                    }
                    else {
                        _this.props.onSuggestionsVisibleChanged(true);
                    }
                    break;
            }
        };
        _this.onResolveSuggestions = function (updatedValue) {
            var suggestions = _this.props.pickerProvider.onFilterIdentities(updatedValue, []);
            if (suggestions !== null) {
                _this.updateSuggestionsList(suggestions, updatedValue);
            }
        };
        _this.onSearchChange = function (event, value) {
            _this.props.onSuggestionsVisibleChanged(!!value);
            if (value.length == 0) {
                var onClear = _this.props.onClear;
                onClear && onClear();
            }
            _this.isEditing.value = true;
            _this.props.onInputChange(value);
            _this.updateValue(value);
        };
        _this.onSuggestionClick = function (suggestion) {
            _this.selectedIndex.value = suggestion.index;
            _this.selectedPersonaChanged(suggestion.item);
            _this.props.onSuggestionsVisibleChanged(false);
        };
        _this.onTextFieldChanged = function (newWidth, newHeight) {
            _this.setState({ width: Math.max(newWidth, 296) });
        };
        _this.selectedPersonaChanged = function (persona) {
            if (_this.lastPickedIdentity !== persona) {
                !!persona && !!_this.props.pickerProvider.addIdentitiesToMRU && _this.props.pickerProvider.addIdentitiesToMRU([persona]);
                if (_this.props.onChange(persona) !== false) {
                    _this.props.onInputChange(persona ? persona.displayName : "");
                    _this.lastPickedIdentity = persona;
                }
                else {
                    _this.props.onInputChange("");
                    _this.props.onChange(undefined);
                    _this.lastPickedIdentity = undefined;
                }
            }
            _this.isEditing.value = false;
        };
        _this.cachedResults = {};
        _this.timerManagement = new TimerManagement();
        _this.lastPickedIdentity = ObservableLike.getValue(props.value);
        _this.state = { width: 296 };
        return _this;
    }
    CustomIdentityPickerDropdown.prototype.render = function () {
        var _this = this;
        var _a = this.props, _b = _a.ariaLabel, ariaLabel = _b === void 0 ? Resources.IdentityPickerPlaceholderText : _b, autoFocus = _a.autoFocus, _c = _a.editPlaceholder, editPlaceholder = _c === void 0 ? Resources.IdentityPickerPlaceholderFocusText : _c, _d = _a.placeholder, placeholder = _d === void 0 ? Resources.IdentityPickerPlaceholderText : _d;
        return (React.createElement(Observer, { suggestionsVisible: this.props.suggestionsVisible }, function (topProps) {
            return (React.createElement(React.Fragment, null,
                React.createElement(Measure, { onMeasure: _this.onTextFieldChanged },
                    React.createElement("div", { className: "bolt-identitypickerdropdown flex-row flex-grow", ref: _this.outerElement, onBlur: _this.onBlur, onKeyDown: _this.onKeyDown },
                        React.createElement(Observer, { hasFocus: _this.hasFocus, selectedIdentity: _this.props.value, textValue: _this.props.textValue }, function (props) {
                            return (React.createElement(TextField, { "aria-autocomplete": "none", "aria-label": ariaLabel, "aria-expanded": topProps.suggestionsVisible, "aria-haspopup": "true", autoFocus: autoFocus, className: css(_this.props.className, "bolt-identitypickerdropdown-textField flex-row flex-center", (topProps.suggestionsVisible || props.hasFocus) && "bolt-identitypickerdropdown-open"), containerClassName: "bolt-identitypickerdropdown-container flex-column flex-grow", onChange: _this.onSearchChange, onClick: _this.onClick, onFocus: _this.onFocus, prefixIconProps: { render: _this.renderPersonaCoin }, placeholder: !props.hasFocus && !props.selectedIdentity ? placeholder : editPlaceholder, ref: _this.inputElement, role: "combobox", suffixIconProps: props.textValue
                                    ? {
                                        iconName: "Clear",
                                        className: "bolt-identity-picker-clearButton fontSize",
                                        onClick: _this.onClearClicked
                                    }
                                    : undefined, value: props.textValue }));
                        }))),
                React.createElement(Observer, { openedIdentityCard: _this.openedIdentityCard, selectedIndex: _this.selectedIndex }, function (props) {
                    return (React.createElement(IdentityPickerSuggestionsList, { calloutProps: {
                            anchorElement: _this.outerElement.current,
                            anchorOrigin: { horizontal: "start" /* start */, vertical: "end" /* end */ },
                            calloutOrigin: { horizontal: "start" /* start */, vertical: "start" /* start */ },
                            contentShadow: true,
                            onDismiss: _this.onPickerDismiss,
                            lightDismiss: true
                        }, suggestionsVisible: topProps.suggestionsVisible || !!props.openedIdentityCard, isLoading: _this.suggestionsLoading, onSuggestionClicked: _this.onSuggestionClick, onClosePersonaCard: _this.closePersonaCard, onDismiss: _this.onPickerDismiss, onOpenPersonaCard: _this.openPersonaCard, openedIdentityCard: props.openedIdentityCard, pickerProvider: _this.props.pickerProvider, suggestions: _this.suggestions, suggestionTarget: _this.outerElement.current, selectedIndex: props.selectedIndex, width: _this.state.width }));
                })));
        }));
    };
    CustomIdentityPickerDropdown.prototype.componentDidMount = function () {
        this.onResolveSuggestions = this.timerManagement.debounce(this.onResolveSuggestions, 250);
        if (this.props.autoFocus) {
            var textValue = ObservableLike.getValue(this.props.textValue);
            if (this.props.pickerProvider.onEmptyInputFocus) {
                this.updateSuggestionsList(this.props.pickerProvider.onEmptyInputFocus());
            }
            else {
                this.updateSuggestionsList(this.props.pickerProvider.onEmptyInputFocus());
            }
            this.inputElement.current && this.inputElement.current.select();
            this.props.onSuggestionsVisibleChanged(true);
        }
        this.setState({ width: this.outerElement.current.clientWidth });
    };
    CustomIdentityPickerDropdown.prototype.componentWillUnmount = function () {
        this.currentPromise && this.currentPromise.cancel();
    };
    CustomIdentityPickerDropdown.prototype.updateSuggestionsList = function (suggestions, initialSearchValue) {
        var _this = this;
        var suggestionsArray = suggestions;
        var suggestionsPromiseLike = suggestions;
        // Check to see if the returned value is an array, if it is then just pass it into the next function.
        // If the returned value is not an array then check to see if it's a promise or PromiseLike. If it is then resolve it asynchronously.
        if (Array.isArray(suggestionsArray)) {
            this.updateSuggestions(suggestionsArray, initialSearchValue);
        }
        else if (suggestionsPromiseLike && suggestionsPromiseLike.then) {
            if (!this.loadingTimer) {
                this.loadingTimer = this.timerManagement.setTimeout(function () {
                    _this.suggestionsLoading.value = true;
                }, 500);
            }
            // Ensure that the promise will only use the callback if it was the most recent one.
            var promise_1 = (this.currentPromise = makeCancelable(suggestionsPromiseLike));
            promise_1.promise.then(function (newSuggestions) {
                if (promise_1 === _this.currentPromise) {
                    _this.suggestionsLoading.value = false;
                    _this.updateSuggestions(newSuggestions, initialSearchValue);
                    if (!!initialSearchValue && initialSearchValue !== "" && _this.suggestions.value && _this.suggestions.value.length > 0) {
                        _this.cachedResults[initialSearchValue] = newSuggestions;
                    }
                    if (_this.loadingTimer) {
                        _this.timerManagement.clearTimeout(_this.loadingTimer);
                        _this.loadingTimer = undefined;
                    }
                }
            });
        }
    };
    CustomIdentityPickerDropdown.prototype.setSuggestions = function (suggestions, selectedIndex) {
        this.suggestions.value = suggestions;
        this.selectedIndex.value = selectedIndex;
    };
    CustomIdentityPickerDropdown.prototype.updateSuggestions = function (suggestions, initialSearchValue) {
        // Only update the suggestions if the initial search value is the same as the current input
        if (initialSearchValue === undefined || (this.inputElement.current && ObservableLike.getValue(this.props.textValue) === initialSearchValue)) {
            this.setSuggestions(suggestions, ObservableLike.getValue(this.props.textValue) === "" ? -1 : 0);
        }
    };
    CustomIdentityPickerDropdown.prototype.updateValue = function (updatedValue) {
        if (this.cachedResults[updatedValue]) {
            this.updateSuggestionsList(this.cachedResults[updatedValue], updatedValue);
        }
        else {
            this.onResolveSuggestions(updatedValue);
        }
    };
    return CustomIdentityPickerDropdown;
}(React.Component));
export { CustomIdentityPickerDropdown };
