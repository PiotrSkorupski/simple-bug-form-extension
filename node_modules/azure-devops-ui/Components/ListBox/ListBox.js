import * as tslib_1 from "tslib";
import "../../CommonImports";
import "../../Core/core.css";
import "./ListBox.css";
import * as React from "react";
import { ObservableLike } from '../../Core/Observable';
import * as Utils_Accessibility from '../../Core/Util/Accessibility';
import { format } from '../../Core/Util/String';
import { renderListCell } from '../../List';
import { ItemsObserver, Observer } from '../../Observer';
import * as Resources from '../../Resources.Dropdown';
import { Spinner } from '../../Spinner';
import { ColumnSelect, renderEmptyCell, SimpleTableCell, Table, TableRow } from '../../Table';
import { css } from '../../Util';
import { DropdownSelection } from '../../Utilities/DropdownSelection';
import { ArrayItemProvider, getItemsValue } from '../../Utilities/Provider';
export var DefaultListBoxWidth = -100;
var ListBox = /** @class */ (function (_super) {
    tslib_1.__extends(ListBox, _super);
    function ListBox(props) {
        var _this = _super.call(this, props) || this;
        _this.tabbableIndex = -1;
        _this.positions = [];
        _this.count = 0;
        _this.loadingChanged = function () {
            if (ObservableLike.getValue(_this.props.loading)) {
                Utils_Accessibility.announce(Resources.AnnounceLoadingItems);
            }
            else {
                Utils_Accessibility.announce(Resources.AnnounceFinishedLoadingItems);
            }
            return true;
        };
        _this.searchingChanged = function () {
            if (ObservableLike.getValue(_this.props.loading)) {
                Utils_Accessibility.announce(Resources.Searching);
            }
            else {
                var resultCount = _this.props.items.length;
                Utils_Accessibility.announce(resultCount > 0 ? format(Resources.AnnounceFilterResultCount, resultCount) : Resources.NoFilterResults, true);
            }
            return true;
        };
        _this.onItemsChanged = function () {
            var items = getListBoxItemsValue(_this.props.items, _this.wrappedItems);
            _this.tabbableIndex = -1;
            _this.positions = [];
            _this.count = 0;
            for (var _i = 0, items_1 = items; _i < items_1.length; _i++) {
                var item = items_1[_i];
                var itemValue = ObservableLike.getValue(item);
                if (itemValue && (itemValue.type === 3 /* Divider */ || itemValue.type === 2 /* Header */)) {
                    _this.positions.push(-1);
                }
                else {
                    if (_this.tabbableIndex === -1 && _this.selection.selectable(_this.positions.length)) {
                        _this.tabbableIndex = _this.positions.length;
                    }
                    _this.positions.push(++_this.count);
                }
            }
            return true;
        };
        _this.onActivate = function (event, tableRow) {
            if (_this.props.onActivate) {
                _this.props.onActivate(event, tableRow.data);
            }
        };
        _this.onSelect = function (event, tableRow) {
            if (_this.props.onSelect) {
                _this.props.onSelect(event, tableRow.data);
            }
        };
        _this.renderListBoxRow = function (index, item, details) {
            var excludeTabStop = _this.props.excludeTabStop;
            var focusable = _this.selection.selectable(index);
            var rowDetails = tslib_1.__assign({}, details, { ariaPosInSet: _this.positions[index] >= 0 ? _this.positions[index] : null, ariaSetSize: _this.positions[index] >= 0 ? _this.count : null, excludeTabStop: excludeTabStop || _this.tabbableIndex !== index, excludeFocusZone: !focusable, singleClickActivation: false });
            return (React.createElement(Observer, { key: index, item: item }, function () { return (React.createElement(TableRow, { key: index, index: index, details: rowDetails, className: css(item.type === 2 /* Header */ && "bolt-list-box-header-row", item.type === 3 /* Divider */ && "bolt-list-box-divider-row", _this.selection.multiSelect && "bolt-list-box-multi-select-row", item.type !== 2 /* Header */ && item.type !== 3 /* Divider */ && "cursor-pointer") }, _this.columns.map(function (tableColumn, columnIndex) {
                if (_this.selection.multiSelect && columnIndex === 0 && !focusable) {
                    if (item.type === 3 /* Divider */) {
                        return null;
                    }
                    else {
                        return renderEmptyCell(index, columnIndex);
                    }
                }
                return tableColumn.renderCell(index, columnIndex, tableColumn, item);
            }))); }));
        };
        _this.renderListBoxCell = function (rowIndex, columnIndex, tableColumn, tableItem) {
            if (tableItem.render) {
                return tableItem.render(rowIndex, columnIndex, tableColumn, tableItem);
            }
            if (tableItem.type === 3 /* Divider */) {
                return (React.createElement(SimpleTableCell, { className: css(tableColumn.className, tableItem.className, _this.selection.multiSelect && "bolt-list-box-divider-multi-select"), columnIndex: columnIndex, colspan: 2, key: columnIndex, tableColumn: tableColumn },
                    React.createElement("div", { className: "bolt-list-box-divider flex-grow" })));
            }
            return (React.createElement(SimpleTableCell, { className: css(tableColumn.className, tableItem.className, tableItem.type === 2 /* Header */ && "bolt-list-box-header"), columnIndex: columnIndex, key: columnIndex, tableColumn: tableColumn }, tableItem && renderListCell(tableItem)));
        };
        _this.selection = props.selection || new DropdownSelection();
        _this.columns = _this.selection.multiSelect ? [new ColumnSelect()] : [];
        _this.columns.push({
            id: "text",
            width: _this.props.width,
            renderCell: _this.props.renderItem || _this.renderListBoxCell,
            className: css("bolt-list-box-text", _this.selection.multiSelect ? "bolt-list-box-text-multi-select" : "bolt-list-box-text-single-select")
        });
        _this.wrappedItems = wrapListBoxItems(_this.props.items);
        _this.onItemsChanged();
        return _this;
    }
    ListBox.prototype.render = function () {
        var _this = this;
        var _a = this.props, className = _a.className, containerClassName = _a.containerClassName, focuszoneProps = _a.focuszoneProps, getUnselectableRanges = _a.getUnselectableRanges, items = _a.items, loading = _a.loading, searching = _a.searching;
        var itemsObservable = { observableValue: items, filter: this.onItemsChanged };
        var itemProvider = this.wrappedItems
            ? new ArrayItemProvider(this.wrappedItems)
            : Array.isArray(items)
                ? new ArrayItemProvider(items)
                : items;
        return (React.createElement(ItemsObserver, { getUnselectableRanges: getUnselectableRanges, items: items, selection: this.selection },
            React.createElement(Observer, { items: itemsObservable, loading: { observableValue: loading || false, filter: this.loadingChanged }, searching: { observableValue: searching || false, filter: this.searchingChanged } }, function (props) {
                if (props.loading || props.searching) {
                    return (React.createElement("div", { className: "bolt-list-box-loading" },
                        React.createElement(Spinner, { size: "medium" /* medium */, label: props.loading ? Resources.Loading : Resources.Searching })));
                }
                return (React.createElement(Table, { className: css(className, "bolt-list-box"), columns: _this.columns, containerClassName: containerClassName, focuszoneProps: focuszoneProps, itemProvider: itemProvider, onActivate: _this.onActivate, onSelect: _this.onSelect, renderRow: _this.renderListBoxRow, scrollable: true, singleClickActivation: false, selection: _this.selection, showHeader: false, showLines: false, spacerWidth: 0 }));
            })));
    };
    ListBox.defaultProps = {
        getUnselectableRanges: getUnselectableRanges,
        width: DefaultListBoxWidth
    };
    return ListBox;
}(React.Component));
export { ListBox };
/**
 * Retrieve a list of unselectable ranges based on a itemSelectable function.
 * @param items the set of items
 * @param itemSelectable A function that returns false when an items is not selectable.
 *        Defaults to checking that the item type is not header or divider.
 */
export function getUnselectableRanges(items, itemSelectable) {
    if (itemSelectable === void 0) { itemSelectable = listBoxItemSelectable; }
    var ranges = [];
    var beginIndex = -1;
    for (var index = 0; index < items.length; index++) {
        if (!itemSelectable(items[index]) && beginIndex < 0) {
            beginIndex = index;
        }
        else if (itemSelectable(items[index]) && beginIndex >= 0) {
            ranges.push({ beginIndex: beginIndex, endIndex: index - 1 });
            beginIndex = -1;
        }
    }
    if (beginIndex >= 0) {
        ranges.push({ beginIndex: beginIndex, endIndex: items.length - 1 });
    }
    return ranges;
}
/**
 * Return whether a ListBoxItem can be selected or not.
 * @param item the LstBoxItem to evaluate
 */
export function listBoxItemSelectable(item) {
    return item.type !== 2 /* Header */ && item.type !== 3 /* Divider */;
}
/**
 * When items is a string[], wrap each item in a ListBoxItem.  Otherwise, do nothing.
 * @param items the items prop
 */
export function wrapListBoxItems(items) {
    if (Array.isArray(items) && items.length && typeof items[0] === "string") {
        return items.map(function (item) {
            return { id: item, text: item };
        });
    }
}
/**
 * Helper to get the value of the items prop.  If items is a string[], it should first be wrapped using wrapListBoxItems.
 * If it's an itemProvider, .value will be called on the provider.
 * @param items the items prop
 * @param  wrappedItems if items is a string[], pass the results of wrapListBoxItems, otherwise, undefined.
 */
export function getListBoxItemsValue(items, wrappedItems) {
    if ($DEBUG) {
        if (Array.isArray(items) && items.length && typeof items[0] === "string" && wrappedItems === undefined) {
            console.warn("a string[] was passed for items and not wrapped first.  Call wrapListBoxItems on items and pass in the results as wrappedItems.");
        }
    }
    return wrappedItems || getItemsValue(items);
}
