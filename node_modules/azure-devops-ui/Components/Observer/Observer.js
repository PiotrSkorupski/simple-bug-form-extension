import * as tslib_1 from "tslib";
import "../../CommonImports";
import "../../Core/core.css";
import * as React from "react";
import { ObservableLike } from '../../Core/Observable';
/**
 * Handles subscription to properties that are IObservableValues, so that components don't have to handle on their own.
 *
 * Usage:
 *
 * <Observer myObservableValue={observableValue} className='foo'>
 *     <MyComponent myObservableValue='' />
 * </Observer>
 *
 * Your component will get re-rendered with the new value of myObservableValue whenever that value changes.
 * Additionally, any additional props set on the Observer will also get passed down.
 */
var Observer = /** @class */ (function (_super) {
    tslib_1.__extends(Observer, _super);
    function Observer(props) {
        var _this = _super.call(this, props) || this;
        _this.subscriptions = {};
        // Initialize the state with the initial value of the observable.
        var state = { values: {}, oldProps: {} };
        for (var propName in props) {
            state.values[propName] = getPropValue(props[propName]);
        }
        _this.state = state;
        return _this;
    }
    Observer.getDerivedStateFromProps = function (props, state) {
        var newState = updateSubscriptionsAndState(state.oldProps, props, state);
        if (newState != null) {
            return tslib_1.__assign({}, newState, { oldProps: props });
        }
        return { oldProps: props };
    };
    Observer.prototype.render = function () {
        var newProps = {};
        // Copy over any properties from the observable component to the children.
        for (var key in this.state.values) {
            if (key !== "children") {
                newProps[key] = this.state.values[key];
            }
        }
        if (typeof this.props.children === "function") {
            var child = this.props.children;
            return child(newProps);
        }
        else {
            var child = React.Children.only(this.props.children);
            return React.cloneElement(child, tslib_1.__assign({}, child.props, newProps), child.props.children);
        }
    };
    Observer.prototype.componentDidMount = function () {
        this.updateSubscriptionsAndStateAfterRender();
    };
    Observer.prototype.componentDidUpdate = function () {
        this.updateSubscriptionsAndStateAfterRender();
    };
    Observer.prototype.componentWillUnmount = function () {
        // Unsubscribe from any of the observable properties.
        for (var propName in this.subscribedProps) {
            this.unsubscribe(propName, this.subscribedProps);
        }
    };
    Observer.prototype.subscribe = function (propName, props) {
        if (propName !== "children") {
            var observableExpression = void 0;
            var observableValue = props[propName];
            var action = void 0;
            // If this is an observableExpression, we need to subscribe to the value
            // and execute the filter on changes.
            if (observableValue && observableValue.observableValue !== undefined) {
                observableExpression = observableValue;
                observableValue = observableExpression.observableValue;
                action = observableExpression.action;
            }
            if (ObservableLike.isObservable(observableValue)) {
                var delegate = this.onValueChanged.bind(this, propName, observableValue, observableExpression);
                ObservableLike.subscribe(observableValue, delegate, action);
                this.subscriptions[propName] = { delegate: delegate, action: action };
            }
        }
    };
    Observer.prototype.unsubscribe = function (propName, props) {
        if (propName !== "children") {
            var observableValue = getObservableValue(props[propName]);
            if (ObservableLike.isObservable(observableValue)) {
                var subscription = this.subscriptions[propName];
                ObservableLike.unsubscribe(observableValue, subscription.delegate, subscription.action);
                delete this.subscriptions[propName];
            }
        }
    };
    Observer.prototype.updateSubscriptionsAndStateAfterRender = function () {
        var newState = updateSubscriptionsAndState(this.subscribedProps, this.props, this.state, this);
        if (newState != null) {
            this.setState(newState);
        }
        this.subscribedProps = tslib_1.__assign({}, this.props);
    };
    Observer.prototype.onValueChanged = function (propName, observableValue, observableExpression, value, action) {
        var setState = true;
        // If this is an ObservableExpression we will call the filter before setting state.
        if (observableExpression && observableExpression.filter) {
            setState = observableExpression.filter(value, action);
        }
        if (setState) {
            this.setState(function (prevState, props) {
                var _a;
                return {
                    values: tslib_1.__assign({}, prevState.values, (_a = {}, _a[propName] = observableValue.value || value, _a))
                };
            });
        }
    };
    return Observer;
}(React.Component));
export { Observer };
function getObservableValue(propValue) {
    if (propValue && propValue.observableValue !== undefined) {
        return propValue.observableValue;
    }
    return propValue;
}
function getPropValue(propValue) {
    return ObservableLike.getValue(getObservableValue(propValue));
}
function updateSubscriptionsAndState(oldProps, newProps, state, component) {
    // We need to unsubscribe from any observable values on old props and
    // subscribe to any observable values on new props.
    // In addition, if any of the values of the observables on the new props
    // differ from the value on the state, then we need to update the state.
    // This is possible if the value of the observable changed while the value
    // was being rendered, but before we had set up the subscription.
    // If we want to unsubscribe/resubscribe, then a component should be passed,
    // since this method is always called statically.
    var newState = tslib_1.__assign({}, state);
    var stateChanged = false;
    if (oldProps) {
        for (var propName in oldProps) {
            var oldValue = getObservableValue(oldProps[propName]);
            var newValue = getObservableValue(newProps[propName]);
            if (oldValue !== newValue) {
                component && component.unsubscribe(propName, oldProps);
                if (newValue === undefined) {
                    delete newState.values[propName];
                    stateChanged = true;
                }
            }
        }
    }
    for (var propName in newProps) {
        var oldValue = oldProps && getObservableValue(oldProps[propName]);
        var newValue = getObservableValue(newProps[propName]);
        if (oldValue !== newValue) {
            component && component.subscribe(propName, newProps);
            // Look for changes in the observables between creation and now.
            if (state.values[propName] !== getPropValue(newValue)) {
                newState.values[propName] = getPropValue(newValue);
                stateChanged = true;
            }
        }
    }
    // If any state updates occurred update the state now.
    if (stateChanged) {
        return newState;
    }
    return null;
}
