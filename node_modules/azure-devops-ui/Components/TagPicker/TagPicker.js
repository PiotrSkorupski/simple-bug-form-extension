import * as tslib_1 from "tslib";
import "../../CommonImports";
import "../../Core/core.css";
import "./TagPicker.css";
import * as React from "react";
import { ObservableArray, ObservableLike, ObservableValue } from '../../Core/Observable';
import { Callout } from '../../Callout';
import { FocusWithin } from '../../FocusWithin';
import { Icon } from '../../Icon';
import { Measure } from '../../Measure';
import { Observer } from '../../Observer';
import { Pill } from '../../Pill';
import { SuggestionsList } from '../../SuggestionsList';
import { css, getSafeId } from '../../Util';
var TagPicker = /** @class */ (function (_super) {
    tslib_1.__extends(TagPicker, _super);
    function TagPicker(props) {
        var _this = _super.call(this, props) || this;
        _this.inputElement = React.createRef();
        _this.outerElement = React.createRef();
        _this.textValue = new ObservableValue("");
        _this.suggestionsVisible = new ObservableValue(false);
        _this.selectedIndex = new ObservableValue(-1);
        _this.selectableTags = new ObservableArray([]);
        _this.onBlur = function () {
            if (!_this.suggestionsVisible.value) {
                _this.textValue.value = "";
                _this.selectableTags.value = [];
            }
        };
        _this.onOuterKeyDown = function (ev) {
            var keyCode = ev.which;
            switch (keyCode) {
                case 46 /* delete */:
                case 8 /* backspace */:
                    if (!ev.isDefaultPrevented() && _this.selectableTags.value.length > 0) {
                        _this.props.onTagsRemoved && _this.props.onTagsRemoved(_this.selectableTags.value);
                        _this.selectableTags.value = [];
                        _this.focusInput();
                        ev.preventDefault();
                    }
                    break;
            }
        };
        _this.onKeyDown = function (ev) {
            var keyCode = ev.which;
            var suggestionsVisible = _this.suggestionsVisible.value;
            var suggestions = ObservableLike.getValue(_this.props.suggestions);
            switch (keyCode) {
                case 27 /* escape */:
                    _this.onSuggestionsDismiss();
                    ev.preventDefault();
                    break;
                case 9 /* tab */:
                case 13 /* enter */:
                    if (!ev.shiftKey) {
                        if (suggestionsVisible) {
                            _this.completeSuggestion();
                            ev.preventDefault();
                        }
                        else if (_this.props.createDefaultItem) {
                            var itemToAdd = _this.props.createDefaultItem(_this.textValue.value, suggestions);
                            itemToAdd && _this.addItem(itemToAdd);
                            ev.preventDefault();
                        }
                    }
                    break;
                case 38 /* upArrow */:
                    if (suggestionsVisible) {
                        _this.selectedIndex.value = Math.max(0, _this.selectedIndex.value - 1);
                        ev.preventDefault();
                    }
                    break;
                case 40 /* downArrow */:
                    if (suggestionsVisible) {
                        _this.selectedIndex.value = Math.min(suggestions.length - 1, _this.selectedIndex.value + 1);
                        ev.preventDefault();
                    }
                    else if (_this.textValue.value !== "" || suggestions.length > 0) {
                        _this.suggestionsVisible.value = true;
                        ev.preventDefault();
                    }
                    break;
            }
        };
        _this.onInputClick = function (event) {
            if (_this.props.onEmptyInputFocus) {
                _this.props.onEmptyInputFocus();
            }
            _this.suggestionsVisible.value = true;
            event && event.preventDefault();
        };
        _this.onInputChange = function (e) {
            _this.textValue.value = e.target.value;
            _this.props.onSearchChanged(e.target.value);
            _this.selectedIndex.value = e.target.value === "" ? -1 : 0;
            _this.suggestionsVisible.value = true;
            e.preventDefault();
        };
        _this.onTagClicked = function (event, suggestion) {
            if (!event || !event.isDefaultPrevented()) {
                var indexOf = _this.indexOfTag(suggestion, _this.selectableTags.value);
                if (!_this.props.onTagsRemoved) {
                    return;
                }
                if (indexOf < 0) {
                    _this.selectableTags.push(suggestion);
                }
                else {
                    _this.selectableTags.splice(indexOf, 1);
                }
                event && event.preventDefault();
            }
        };
        _this.onTagRemoved = function (suggestion) {
            var indexOf = _this.indexOfTag(suggestion, _this.selectableTags.value);
            // If this is selected, remove the selection before removing the tag from the list
            if (indexOf >= 0) {
                _this.selectableTags.splice(indexOf, 1);
            }
            _this.props.onTagRemoved(suggestion);
        };
        _this.onTagPickerSizeChanged = function (newWidth, newHeight) {
            _this.setState({ width: newWidth });
        };
        _this.completeSuggestion = function () {
            var suggestionToAdd = ObservableLike.getValue(_this.props.suggestions)[_this.selectedIndex.value];
            !!suggestionToAdd && _this.addItem(suggestionToAdd);
        };
        _this.onSuggestionClick = function (suggestion) {
            _this.addItem(suggestion.item);
        };
        _this.addItem = function (item) {
            _this.suggestionsVisible.value = false;
            _this.props.onTagAdded(item);
            _this.textValue.value = "";
            _this.selectedIndex.value = -1;
            _this.focusInput();
        };
        _this.enterEditMode = function () {
            _this.focusInput();
            _this.onInputClick();
        };
        _this.focusInput = function () {
            if (_this.inputElement.current) {
                _this.inputElement.current.focus();
                _this.inputElement.current.select();
            }
        };
        _this.onSuggestionsDismiss = function () {
            _this.suggestionsVisible.value = false;
            _this.focusInput();
        };
        _this.indexOfTag = function (tag, list) {
            return list.findIndex(function (item) {
                return _this.props.areTagsEqual(item, tag);
            });
        };
        _this.state = { width: 296 };
        return _this;
    }
    TagPicker.prototype.render = function () {
        var _this = this;
        var _a = this.props, ariaLabel = _a.ariaLabel, convertItemToPill = _a.convertItemToPill, createDefaultItem = _a.createDefaultItem, noResultsFoundText = _a.noResultsFoundText, onTagsRemoved = _a.onTagsRemoved, placeholderText = _a.placeholderText, prefixIconProps = _a.prefixIconProps, renderSuggestionItem = _a.renderSuggestionItem, selectedTags = _a.selectedTags, suggestions = _a.suggestions, suggestionsLoading = _a.suggestionsLoading, suggestionsLoadingText = _a.suggestionsLoadingText;
        return (React.createElement(React.Fragment, null,
            React.createElement(FocusWithin, { onBlur: this.onBlur }, function (focusStatus) {
                return (React.createElement(Observer, { suggestionsVisible: _this.suggestionsVisible, selectedIndex: _this.selectedIndex, selectableTags: _this.selectableTags, selectedTags: selectedTags, suggestions: suggestions, textValue: _this.textValue }, function (props) {
                    if (createDefaultItem) {
                        var genericItem = createDefaultItem(_this.textValue.value, props.suggestions.concat(props.selectedTags));
                        genericItem && props.suggestions.unshift(genericItem);
                    }
                    return (React.createElement(Measure, { onMeasure: _this.onTagPickerSizeChanged },
                        React.createElement("div", { className: css("bolt-tag-picker", (focusStatus.hasFocus || props.suggestionsVisible) && "edit"), ref: _this.outerElement, onBlur: focusStatus.onBlur, onFocus: focusStatus.onFocus },
                            React.createElement("div", { className: "bolt-tag-picker-group flex-center flex-row flex-wrap", onKeyDown: onTagsRemoved && _this.onOuterKeyDown },
                                props.selectedTags.length === 0 && prefixIconProps ? (React.createElement(Icon, tslib_1.__assign({}, prefixIconProps, { className: css(prefixIconProps.className, "bolt-tag-picker-prefix-icon") }))) : null,
                                props.selectedTags.map(function (suggestion, index) {
                                    var tagPill = convertItemToPill(suggestion, index);
                                    var indexOf = _this.indexOfTag(suggestion, props.selectableTags);
                                    return (React.createElement("div", { key: getSafeId("bolt-tag-picker-pill" + index), className: "scroll-hidden" },
                                        React.createElement(Pill, tslib_1.__assign({}, tagPill, { className: css("bolt-tag-picker-pill", onTagsRemoved && "bolt-people-picker-pill-selectable", indexOf >= 0 && "active"), contentClassName: "text-ellipsis", onClick: function (ev) {
                                                _this.onTagClicked(ev, suggestion);
                                            }, onRemoveClick: function (event) {
                                                _this.onTagRemoved(suggestion);
                                                event.preventDefault();
                                            } }), tagPill.content)));
                                }),
                                React.createElement("div", { className: "bolt-tag-picker-add-icon-div flex-row" },
                                    !focusStatus.hasFocus && props.selectedTags.length > 0 && !props.suggestionsVisible && (React.createElement(Icon, { className: "bolt-tag-picker-add-icon cursor-pointer", iconName: "Add", onClick: _this.focusInput })),
                                    React.createElement("input", { "aria-label": ariaLabel, "aria-expanded": props.suggestionsVisible, "aria-haspopup": "true", className: "bolt-tag-picker-input flex-row flex-grow scroll-hidden", onChange: _this.onInputChange, onKeyDown: _this.onKeyDown, onClick: _this.onInputClick, placeholder: props.selectedTags.length === 0 || focusStatus.hasFocus ? placeholderText : undefined, ref: _this.inputElement, role: "comboBox", type: "text", value: props.textValue }))))));
                }));
            }),
            React.createElement(Observer, { suggestionsVisible: this.suggestionsVisible, suggestionsLoading: suggestionsLoading, selectedIndex: this.selectedIndex, suggestions: suggestions, textValue: this.textValue }, function (props) {
                return props.suggestionsVisible ? (React.createElement(Callout, { anchorElement: _this.outerElement.current || undefined, anchorOrigin: { horizontal: "start" /* start */, vertical: "end" /* end */ }, calloutOrigin: { horizontal: "start" /* start */, vertical: "start" /* start */ }, contentClassName: "bolt-tag-picker-callout-content scroll-hidden", contentShadow: true, onDismiss: _this.onSuggestionsDismiss, lightDismiss: true },
                    React.createElement(SuggestionsList, { isLoading: props.suggestionsLoading, loadingText: suggestionsLoadingText, noResultsFoundText: noResultsFoundText, onSuggestionClicked: _this.onSuggestionClick, renderSuggestion: renderSuggestionItem, selectedIndex: props.selectedIndex, suggestions: props.suggestions, width: _this.state.width }))) : (React.createElement("div", null));
            })));
    };
    return TagPicker;
}(React.Component));
export { TagPicker };
