import * as tslib_1 from "tslib";
import "../../CommonImports";
import "../../Core/core.css";
import "./Tree.css";
import "./TreeExpand.css";
import * as React from "react";
import { ObservableLike } from '../../Core/Observable';
import { FocusWithin } from '../../FocusWithin';
import { FocusZone, FocusZoneContext } from '../../FocusZone';
import { renderListCell } from '../../List';
import { Observer } from '../../Observer';
import { renderLoadingCell, SimpleTableCell, Table } from '../../Table';
import { css, preventDefault } from '../../Util';
import { getTabIndex } from '../../Utilities/Focus';
import { TreeExpand } from "./TreeExpand";
var Tree = /** @class */ (function (_super) {
    tslib_1.__extends(Tree, _super);
    function Tree() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.table = React.createRef();
        _this.renderRow = function (rowIndex, item, details) {
            // Since the underlying table is unable to determine whether or not a row
            // is in a loading state since the observable value is within the ITreeItemEx
            // we need to handle this in the row rendering.
            return (React.createElement(Observer, { data: item.underlyingItem.data }, function (props) {
                if (props.data) {
                    // We need to forward the onToggle handler to the treeItemEx before it is rendered.
                    item.onToggle = item.underlyingItem.childItems ? _this.props.onToggle : undefined;
                    // First determine if the item supplied a custom row rendering function, if not
                    // attempt to use the global row rendering function.
                    var renderRow = item.underlyingItem.data.renderRow || _this.props.renderRow;
                    if (renderRow) {
                        return renderRow(rowIndex, item, details);
                    }
                    return (React.createElement(TreeRow, { index: rowIndex, details: details }, _this.props.columns.map(function (tableColumn, columnIndex) {
                        return tableColumn.renderCell(rowIndex, columnIndex, tableColumn, item);
                    })));
                }
                else {
                    var renderLoadingRow = _this.props.renderLoadingRow;
                    // If a custom row loading animation is available use it.
                    if (renderLoadingRow) {
                        return renderLoadingRow(rowIndex, details);
                    }
                    // Return the default row loading animation.
                    return (React.createElement(TreeRow, { index: rowIndex, details: details }, _this.props.columns.map(function (treeColumn, columnIndex) {
                        var children = renderLoadingCell(treeColumn.columnLayout);
                        if (treeColumn.hierarchical) {
                            children = React.createElement(TreeExpand, { depth: details.data.depth }, children);
                        }
                        return SimpleTableCell({ className: "bolt-tree-cell", columnIndex: columnIndex, children: children });
                    })));
                }
            }));
        };
        return _this;
    }
    Tree.prototype.render = function () {
        var _a = this.props.role, role = _a === void 0 ? "treegrid" : _a;
        return (React.createElement(Table, { behaviors: this.props.behaviors, className: this.props.className, columns: this.props.columns, containerClassName: this.props.containerClassName, eventDispatch: this.props.eventDispatch, focuszoneProps: this.props.focuszoneProps, id: this.props.id, itemProvider: this.props.itemProvider, onActivate: this.props.onActivate, onFocus: this.props.onFocus, onSelect: this.props.onSelect, pageSize: this.props.pageSize, renderHeader: this.props.renderHeader, renderRow: this.renderRow, renderSpacer: this.props.renderSpacer, role: role, rowHeight: this.props.rowHeight, ref: this.table, scrollable: this.props.scrollable, selection: this.props.selection, singleClickActivation: this.props.singleClickActivation, showHeader: this.props.showHeader, showLines: this.props.showLines, virtualize: this.props.virtualize }));
    };
    Tree.prototype.addOverlay = function (id, rowIndex, render, zIndex) {
        if (zIndex === void 0) { zIndex = 0; }
        if (this.table.current) {
            return this.table.current.addOverlay(id, rowIndex, render, zIndex);
        }
    };
    Tree.prototype.removeOverlay = function (id) {
        if (this.table.current) {
            return this.table.current.removeOverlay(id);
        }
    };
    Tree.prototype.getFocusIndex = function () {
        if (this.table.current) {
            return this.table.current.getFocusIndex();
        }
        return -1;
    };
    Tree.prototype.scrollIntoView = function (rowIndex, options) {
        if (this.table.current) {
            return this.table.current.scrollIntoView(rowIndex, options);
        }
    };
    return Tree;
}(React.Component));
export { Tree };
var TreeRow = /** @class */ (function (_super) {
    tslib_1.__extends(TreeRow, _super);
    function TreeRow() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.rowElement = React.createRef();
        _this.onFocus = function (event) {
            _this.props.details.onFocusItem(_this.props.index, event);
        };
        _this.onKeyDown = function (event) {
            if (!event.defaultPrevented) {
                if (_this.rowElement.current === event.nativeEvent.srcElement) {
                    var data = _this.props.details.data;
                    if (data) {
                        if (data.onToggle) {
                            var expanded = data.underlyingItem.expanded;
                            if ((event.which === 39 /* rightArrow */ && !expanded) || (event.which === 37 /* leftArrow */ && expanded)) {
                                data.onToggle(event, data);
                                event.preventDefault();
                            }
                        }
                    }
                }
            }
        };
        _this.onPostprocessKeyStroke = function (event) {
            if (!event.defaultPrevented) {
                if (event.which === 37 /* leftArrow */) {
                    _this.rowElement.current.focus();
                    event.preventDefault();
                }
            }
            return 1 /* IgnoreNone */;
        };
        return _this;
    }
    TreeRow.prototype.render = function () {
        var _this = this;
        var _a = this.props, details = _a.details, index = _a.index;
        var data = details.data, excludeFocusZone = details.excludeFocusZone, renderSpacer = details.renderSpacer, selection = details.selection, singleClickActivation = details.singleClickActivation;
        return (React.createElement(FocusWithin, { onFocus: this.onFocus }, function (focusStatus) {
            return (React.createElement(FocusZoneContext.Consumer, null, function (rowContext) {
                return (React.createElement(FocusZone, { direction: 1 /* Horizontal */, postprocessKeyStroke: _this.onPostprocessKeyStroke },
                    React.createElement("tr", { "aria-busy": data === undefined, "aria-expanded": ObservableLike.getValue((data && data.underlyingItem.expanded) || false), "aria-level": data ? data.depth : undefined, "aria-rowindex": index + 1, "aria-selected": selection && selection.selected(index), className: css(_this.props.className, "bolt-tree-row bolt-table-row bolt-list-row", index === 0 && "first-row", focusStatus.hasFocus && "focused", selection && selection.selected(index) && "selected", singleClickActivation && "single-click-activation"), "data-focuszone": excludeFocusZone ? undefined : rowContext.focuszoneId, "data-row-index": index, tabIndex: getTabIndex(details), onBlur: focusStatus.onBlur, onFocus: focusStatus.onFocus, onKeyDown: _this.onKeyDown, ref: _this.rowElement },
                        React.createElement("td", { key: "left-spacer", className: "bolt-table-cell-compact bolt-table-cell bolt-list-cell", role: "presentation" }, renderSpacer && renderSpacer(index, true)),
                        _this.props.children,
                        React.createElement("td", { key: "right-spacer", className: "bolt-table-cell-compact bolt-table-cell bolt-list-cell", role: "presentation" }, renderSpacer && renderSpacer(index, false)))));
            }));
        }));
    };
    return TreeRow;
}(React.Component));
export { TreeRow };
/**
 * Standard cell renderer for a tree cell with expandable children. This will use the tree items
 * state to determine whether or not the row is expanded etc.
 */
export function ExpandableTreeCell(props) {
    var colspan = props.colspan, columnIndex = props.columnIndex, contentClassName = props.contentClassName, treeItem = props.treeItem, treeColumn = props.treeColumn;
    var depth = treeItem.depth, onToggle = treeItem.onToggle, underlyingItem = treeItem.underlyingItem;
    var expanded = underlyingItem.expanded;
    var children = (React.createElement(TreeExpand, { expanded: expanded, depth: depth, indentationSize: treeColumn && treeColumn.indentationSize, onClick: preventDefault, onToggle: onToggle ? function (event) { return onToggle(event, treeItem); } : undefined }, props.children));
    return SimpleTableCell({
        children: children,
        className: css(props.className, "bolt-tree-cell"),
        colspan: colspan,
        columnIndex: columnIndex,
        contentClassName: contentClassName,
        tableColumn: treeColumn
    });
}
export function renderExpandableTreeCell(rowIndex, columnIndex, treeColumn, treeItem) {
    var underlyingItem = treeItem.underlyingItem;
    var data = ObservableLike.getValue(underlyingItem.data);
    var treeCell = data && data[treeColumn.id];
    // Do not include padding if the table cell has an href
    var hasLink = !!(treeCell && typeof treeCell !== "string" && typeof treeCell !== "number" && treeCell.href);
    return ExpandableTreeCell({
        children: treeCell && renderListCell(treeCell),
        className: treeColumn.className,
        columnIndex: columnIndex,
        contentClassName: hasLink ? "bolt-table-cell-content-with-link" : undefined,
        treeItem: treeItem,
        treeColumn: treeColumn
    });
}
export function renderTreeCell(rowIndex, columnIndex, treeColumn, treeItem) {
    var underlyingItem = treeItem.underlyingItem;
    var data = ObservableLike.getValue(underlyingItem.data);
    var treeCell = data && data[treeColumn.id];
    // Do not include padding if the table cell has an href
    var hasLink = !!(treeCell && typeof treeCell !== "string" && typeof treeCell !== "number" && treeCell.href);
    return SimpleTableCell({
        className: treeColumn.className,
        children: treeCell && renderListCell(treeCell),
        columnIndex: columnIndex,
        contentClassName: hasLink ? "bolt-table-cell-content-with-link" : undefined,
        tableColumn: treeColumn
    });
}
