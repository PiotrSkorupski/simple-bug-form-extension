import * as tslib_1 from "tslib";
import "../../CommonImports";
import "../../Core/core.css";
import "./List.css";
import "./ListDropIndicator.css";
import * as React from "react";
import { ObservableArray, ObservableLike } from '../../Core/Observable';
import { FocusWithin } from '../../FocusWithin';
import { FocusZone, FocusZoneContext } from '../../FocusZone';
import { Icon } from '../../Icon';
import { Intersection, IntersectionContext } from '../../Intersection';
import { Link } from '../../Link';
import { Observer } from '../../Observer';
import { Tooltip } from '../../TooltipEx';
import { css, eventTargetContainsNode, getSafeId } from '../../Util';
import { EventDispatch } from '../../Utilities/Dispatch';
import { getTabIndex } from '../../Utilities/Focus';
/**
 * The List component is used to render a collection of items with a series of rows.
 */
var List = /** @class */ (function (_super) {
    tslib_1.__extends(List, _super);
    function List(props) {
        var _this = _super.call(this, props) || this;
        // Track the table element used to render the rows.
        _this.bodyElement = React.createRef();
        _this.listElement = React.createRef();
        // Manage data about pages, including their spacers.
        _this.spacerElements = {};
        // ScrollTo data, used to track across updates when we need to materialize rows.
        _this.scrollToIndex = -1;
        _this.scrollToOptions = undefined;
        // Focus/Selection management members.
        _this.selectOnFocus = true;
        _this.focusIndex = -1;
        _this.pivotIndex = -1;
        _this.onClick = function (event) {
            _this.onDispatch(event);
            if (!event.defaultPrevented) {
                if (_this.listElement.current && !eventTargetContainsNode(event, ["A"], _this.listElement.current)) {
                    var rowIndex = cellFromEvent(event).rowIndex;
                    var item = ObservableLike.getValue(_this.state.rows[rowIndex]);
                    if (rowIndex >= 0 && item) {
                        var listRow = { data: item, index: rowIndex };
                        // Even for singleClickActivation we fire the selection before activation.
                        _this.processSelectionEvent(event, listRow);
                        // For singleClickActivation we want the activation as well.
                        if (_this.props.singleClickActivation) {
                            _this.rowActivated(event, listRow);
                        }
                    }
                }
            }
        };
        _this.onDispatch = function (event) {
            _this.state.eventDispatch.dispatchEvent(event);
        };
        _this.onDoubleClick = function (event) {
            _this.onDispatch(event);
            if (!event.defaultPrevented) {
                var rowIndex = cellFromEvent(event).rowIndex;
                var item = ObservableLike.getValue(_this.state.rows[rowIndex]);
                if (rowIndex >= 0 && item) {
                    _this.rowActivated(event, { data: item, index: rowIndex });
                }
            }
        };
        _this.onFocusBody = function (event) {
            // The first time the list gets focus we need to select initial row if we are performing
            // selection of focus.
            if (_this.selectOnFocus) {
                var selection = _this.props.selection;
                if (!selection || selection.selectOnFocus) {
                    var rowIndex = _this.focusIndex;
                    if (rowIndex >= 0) {
                        var item = ObservableLike.getValue(_this.state.rows[rowIndex]);
                        if (item) {
                            _this.processSelectionEvent(event, { data: item, index: rowIndex });
                        }
                    }
                }
                _this.selectOnFocus = false;
            }
        };
        _this.onFocusItem = function (rowIndex, event) {
            var focusIndex = _this.focusIndex;
            if (focusIndex !== rowIndex) {
                // We need to re-render the previously focused row and newly focused row so we will
                // clear the cached values.
                if (focusIndex >= 0) {
                    delete _this.state.renderedRows[focusIndex];
                }
                else if (_this.props.defaultTabbableRow !== undefined) {
                    // If there was a tabble row that was not the focusIndex row we need to update this
                    // row as well to get it re-rendered without the tabIndex.
                    delete _this.state.renderedRows[_this.props.defaultTabbableRow];
                }
                delete _this.state.renderedRows[rowIndex];
                _this.focusIndex = rowIndex;
                var item = ObservableLike.getValue(_this.state.rows[rowIndex]);
                if (item) {
                    _this.rowFocused(event, { data: item, index: rowIndex });
                }
            }
        };
        _this.onKeyDown = function (event) {
            _this.onDispatch(event);
            if (!event.defaultPrevented) {
                var focusIndex_1 = _this.focusIndex;
                var item_1 = ObservableLike.getValue(_this.state.rows[focusIndex_1]);
                if (item_1) {
                    if (event.which === 13 /* enter */) {
                        if (focusIndex_1 >= 0 && !eventTargetContainsNode(event, ["A"])) {
                            _this.rowActivated(event, { data: item_1, index: focusIndex_1 });
                        }
                    }
                    else if (event.which === 32 /* space */) {
                        _this.processSelectionEvent(event, { data: item_1, index: focusIndex_1 });
                        event.preventDefault();
                    }
                    else if (event.which === 38 /* upArrow */ || event.which === 40 /* downArrow */) {
                        var selection = _this.props.selection;
                        if (!selection || selection.selectOnFocus) {
                            event.persist();
                            // Need to wait for the keyboard event to be processed by the focuszone.
                            window.setTimeout(function () {
                                if (_this.focusIndex != focusIndex_1) {
                                    _this.processSelectionEvent(event, { data: item_1, index: _this.focusIndex });
                                }
                            }, 0);
                        }
                    }
                }
            }
        };
        _this.onIntersect = function () {
            // If virtualization is disabled, we will not attempt to adjust the viewport.
            if (!_this.props.virtualize) {
                return;
            }
            var rowCount = _this.state.rowCount;
            var _a = _this.state, firstRow = _a.firstRow, lastRow = _a.lastRow, rowHeight = _a.rowHeight;
            // console.log({ phase: "onIntersect - Start", firstRow, lastRow, rowHeight });
            // Ignore events if we dont have a our basic elements resolved (this should never happen).
            if (!_this.listElement.current || !_this.bodyElement.current) {
                return;
            }
            // We are going to enumerate all the children, if the row is in the viewport
            // we will determine if it should be paged out.
            var rowElements = _this.bodyElement.current.children;
            // If a rowHeight was specified we will compute on based on the average rowHeight in the
            // first page rendered.
            if (rowHeight === 0) {
                if (rowElements.length > 0) {
                    var totalHeight = 0;
                    var childCount = 0;
                    // Loop through all children and average the rowHeight's.
                    for (var childIndex = 0; childIndex < rowElements.length; childIndex++) {
                        var childHeight = _this.bodyElement.current.children[childIndex].getBoundingClientRect().height;
                        if (childHeight > 0) {
                            totalHeight += childHeight;
                            childCount++;
                        }
                    }
                    // Make sure we have at least one child row that has size.
                    if (childCount > 0) {
                        rowHeight = Math.ceil(totalHeight / childCount);
                    }
                }
                if (rowHeight === 0) {
                    return;
                }
                // console.log({ phase: "onIntersect - Compute RowHeight", rowHeight });
            }
            // Determine the location of the intersection within the page. This is the element
            // we are scrolling within.
            var intersectionRect = _this.context.root.getBoundingClientRect();
            // Track the first and last row elements for adjusting the range.
            var firstRowElement;
            var lastRowElement;
            var firstRowUpdated = firstRow;
            var lastRowUpdated = lastRow;
            // Go through the viewport pages and determine if any are out of range and should be
            // paged out. Range is defined as more than 1 page of estimated rows away from the
            // nearest edge. If you dont allow for 1 page of estimated rows it may thrash pages
            // in and out of materialization.
            for (var childIndex = 0; childIndex < rowElements.length; childIndex++) {
                // Determine if this child is in the viewport, ignore rows that are not.
                var rowElement = rowElements[childIndex];
                var rowIndex = getAttributeAsNumber(rowElement, "data-row-index");
                if (rowIndex >= firstRow && rowIndex <= lastRow) {
                    var rowRect = rowElement.getBoundingClientRect();
                    // Make sure to leave some extra room above and below the visible rectangle to handle
                    // variable height rows. This helps prevent jittering when paging rows out.
                    if (rowRect.bottom < intersectionRect.top - _this.state.pageSize * _this.state.rowHeight) {
                        firstRowUpdated++;
                    }
                    else if (rowRect.top > intersectionRect.bottom + _this.state.pageSize * _this.state.rowHeight) {
                        lastRowUpdated--;
                    }
                    // We will save the first and last rows for later computations.
                    if (rowIndex === firstRow) {
                        firstRowElement = rowElement;
                    }
                    if (rowIndex === lastRow) {
                        lastRowElement = rowElement;
                    }
                }
            }
            // If the row range is inverted (top above bottom) then all rows have been hidden and we should
            // recompute the viewport based on the scrollTop of our intersection and intersection height.
            if (firstRowUpdated > lastRowUpdated) {
                var scrollTop = _this.context.root.scrollTop - _this.listElement.current.offsetTop;
                firstRowUpdated = Math.max(0, Math.min(rowCount, Math.floor(scrollTop / rowHeight)));
                lastRowUpdated = Math.min(rowCount, firstRowUpdated + Math.ceil(intersectionRect.height / rowHeight));
            }
            else {
                // If the firstPage didnt move down, we may need more pages above.
                if (firstRowUpdated === firstRow && firstRowElement) {
                    var rowRect = firstRowElement.getBoundingClientRect();
                    var availableSpace = rowRect.top - intersectionRect.top;
                    if (availableSpace > 0) {
                        firstRowUpdated -= Math.ceil(availableSpace / rowHeight);
                    }
                }
                // If the lastPage didnt move up, we may need more pages below.
                if (lastRowUpdated === lastRow && lastRowElement) {
                    var rowRect = lastRowElement.getBoundingClientRect();
                    var availableSpace = intersectionRect.bottom - rowRect.bottom;
                    if (availableSpace > 0) {
                        lastRowUpdated += Math.ceil(availableSpace / rowHeight);
                    }
                }
            }
            // Make sure our page boundary stays in the available page range.
            firstRowUpdated = Math.max(firstRowUpdated, 0);
            lastRowUpdated = Math.min(lastRowUpdated, rowCount - 1);
            // console.log({ phase: "onIntersect - End", firstRowUpdated, lastRowUpdated, rowHeight });
            // Update our state if and only if something has changed.
            if (firstRowUpdated !== firstRow || lastRowUpdated !== lastRow || rowHeight !== _this.state.rowHeight) {
                //
                // @TODO: We need to unload data for pages that are no longer rendererd.
                // This means not in the viewport or within any other rendered range.
                //
                // console.log({ phase: "onIntersect - stateChange", firstRowUpdated, lastRowUpdated });
                _this.setState({ firstRow: firstRowUpdated, lastRow: lastRowUpdated, rowHeight: rowHeight });
            }
        };
        _this.onMouseDownBody = function (event) {
            // If the table body gets a mousedown, we will never need to fire the selection event when
            // the list gets focus since the mouse event will cause the selection.
            _this.selectOnFocus = false;
        };
        var rowCount = props.itemProvider.length;
        var pageSize = props.pageSize;
        _this.state = {
            columnCount: 1,
            eventDispatch: props.eventDispatch || new EventDispatch(),
            firstRow: 0,
            itemProvider: props.itemProvider,
            lastRow: _this.props.virtualize ? Math.min(props.initialPageCount * pageSize, rowCount - 1) : rowCount - 1,
            overlays: new ObservableArray(),
            pageSize: pageSize,
            renderedRows: {},
            rowCount: rowCount,
            rowHeight: props.rowHeight || 0,
            rows: {},
            scrollTop: 0
        };
        // Initialize the supplied behaviors.
        if (props.behaviors) {
            for (var _i = 0, _a = props.behaviors; _i < _a.length; _i++) {
                var behavior = _a[_i];
                if (behavior.initialize) {
                    behavior.initialize(props, _this, _this.state.eventDispatch);
                }
            }
        }
        return _this;
    }
    List.getDerivedStateFromProps = function (props, state) {
        var rowCount = props.itemProvider.length;
        var firstRow = state.firstRow;
        var lastRow = state.lastRow;
        if (rowCount !== state.rowCount) {
            firstRow = Math.max(0, Math.min(state.firstRow, rowCount));
            lastRow = props.virtualize
                ? Math.max(firstRow, Math.min(state.lastRow + (state.lastRow === state.rowCount - 1 ? props.pageSize : 0), rowCount - 1))
                : rowCount - 1;
        }
        // Ensure out pages and providers are appropriately computed.
        var updatedState = {
            firstRow: firstRow,
            itemProvider: props.itemProvider,
            lastRow: lastRow,
            pageSize: props.pageSize,
            rowCount: rowCount
        };
        // If there are changes to the props that affect the cached data, we need it clear it.
        if (props.itemProvider !== state.itemProvider || props.columnCount !== state.columnCount) {
            updatedState.columnCount = props.columnCount;
            updatedState.renderedRows = {};
            updatedState.rows = {};
        }
        // console.log(updatedState);
        return updatedState;
    };
    List.prototype.render = function () {
        var _this = this;
        var _a = this.props, className = _a.className, focuszoneProps = _a.focuszoneProps, id = _a.id, maxWidth = _a.maxWidth, minWidth = _a.minWidth, role = _a.role, width = _a.width;
        var _b = this.state, firstRow = _b.firstRow, lastRow = _b.lastRow, rowCount = _b.rowCount;
        var focusIndex = this.focusIndex;
        var rows = [];
        // Number of pages each spacer takes up. There are potentially two spacers above
        // or below the view port. They surround the focus range when the focus range is
        // not within the viewport.
        var topSpacer1 = 0;
        var topSpacer2 = firstRow;
        var bottomSpacer2 = Math.max(0, rowCount - lastRow - 1);
        var bottomSpacer1 = 0;
        var firstFocusRow = Number.MAX_SAFE_INTEGER;
        var lastFocusRow = 0;
        // Compute the range of focus pages, these will be either before or after the pages
        // in the viewport. We need to ensure we have one row before and one row after the
        // focus row to support arrowing up and down.
        if (focusIndex !== -1) {
            firstFocusRow = Math.max(0, focusIndex - 3);
            lastFocusRow = Math.min(rowCount, focusIndex + 3);
            // Make sure we dont draw any of the pages that are in the viewport.
            if (firstFocusRow < firstRow) {
                lastFocusRow = Math.min(lastFocusRow, firstRow - 1);
                topSpacer1 = firstFocusRow;
                topSpacer2 = firstRow - lastFocusRow - 1;
            }
            else if (lastFocusRow > lastRow) {
                firstFocusRow = Math.max(firstFocusRow, lastRow + 1);
                bottomSpacer2 = firstFocusRow - lastRow - 1;
                bottomSpacer1 = Math.max(0, rowCount - lastFocusRow - 1);
            }
        }
        // console.log({ phase: "render", firstRow, lastRow, topSpacer1, topSpacer2, bottomSpacer2, bottomSpacer1 });
        rows.push(this.renderSpacer("st1", topSpacer1));
        // If the focus pages are before the viewport render them up too
        // the first page but not including the first page.
        if (firstFocusRow < firstRow) {
            for (var rowIndex = firstFocusRow; rowIndex <= lastFocusRow; rowIndex++) {
                rows.push(this.renderRow(rowIndex));
            }
        }
        rows.push(this.renderSpacer("st2", topSpacer2));
        // Go through each of the rendered pages and generate the child component.
        for (var rowIndex = firstRow; rowIndex <= lastRow; rowIndex++) {
            rows.push(this.renderRow(rowIndex));
        }
        rows.push(this.renderSpacer("sb2", bottomSpacer2));
        // If the focus pages are after the last page in the viewport render
        // them but not including the last page.
        if (lastFocusRow > lastRow) {
            for (var rowIndex = firstFocusRow; rowIndex <= lastFocusRow; rowIndex++) {
                rows.push(this.renderRow(rowIndex));
            }
        }
        rows.push(this.renderSpacer("sb1", bottomSpacer1));
        var list = (React.createElement("table", { "aria-colcount": this.props.columnCount, "aria-rowcount": this.state.itemProvider.length, className: css(className, "bolt-list relative"), id: getSafeId(id), onClick: this.onClick, onDoubleClick: this.onDoubleClick, onDragEnd: this.onDispatch, onDragEnter: this.onDispatch, onDragExit: this.onDispatch, onDragOver: this.onDispatch, onDragStart: this.onDispatch, onDrop: this.onDispatch, onKeyDown: this.onKeyDown, onKeyUp: this.onDispatch, onMouseDown: this.onDispatch, onTouchStart: this.onDispatch, ref: this.listElement, role: role || "listbox", style: { maxWidth: maxWidth, minWidth: minWidth, width: width } },
            this.props.renderHeader && this.props.renderHeader(),
            React.createElement("tbody", { className: "relative", onFocus: this.onFocusBody, onMouseDown: this.onMouseDownBody, ref: this.bodyElement },
                this.renderOverlay(this.listElement),
                rows)));
        if (focuszoneProps) {
            list = (React.createElement(FocusZone, tslib_1.__assign({}, focuszoneProps, { skipHiddenCheck: true }), list));
        }
        return (React.createElement(Observer, { itemProvider: {
                // Supply an IObservableExpression to elevate the provider change to a state
                // update for the entire component instead of just the observer.
                filter: function (change, action) {
                    // Notify the selection about the change to the items.
                    if (_this.props.selection) {
                        _this.props.selection.onItemsChanged(change, action);
                    }
                    // @NOTE: For now we will just wipe out the entire cache, we can do an optimized
                    // update to the cache based on the rows that changed.
                    var updatedState = {
                        renderedRows: {},
                        rows: {}
                    };
                    // If their is a well defined rowcount we will update it and the maxPage.
                    if (_this.state.rowCount !== -1) {
                        var countChange = (change.addedItems ? change.addedItems.length : 0) - (change.removedItems ? change.removedItems.length : 0);
                        if (countChange) {
                            updatedState.rowCount = _this.state.rowCount + countChange;
                            updatedState.firstRow = Math.max(0, Math.min(_this.state.firstRow, updatedState.rowCount - 1));
                            updatedState.lastRow = _this.props.virtualize
                                ? Math.max(updatedState.firstRow, Math.min(_this.state.lastRow +
                                    (change.index >= _this.state.firstRow && change.index <= _this.state.lastRow + 1
                                        ? Math.min(_this.state.pageSize, countChange)
                                        : 0), updatedState.rowCount - 1))
                                : updatedState.rowCount - 1;
                        }
                    }
                    // console.log(updatedState);
                    _this.setState(updatedState);
                    return false;
                },
                observableValue: this.props.itemProvider
            } }, function () { return list; }));
    };
    List.prototype.componentDidMount = function () {
        this.context.register(this.onIntersect);
    };
    List.prototype.componentDidUpdate = function () {
        var scrollToIndex = this.scrollToIndex;
        if (scrollToIndex !== -1) {
            var parentElement = this.bodyElement.current;
            var _a = this.state, firstRow = _a.firstRow, lastRow = _a.lastRow;
            // If the row is materialized, we will ensure it is in the viewport.
            if (scrollToIndex >= firstRow && scrollToIndex <= lastRow && parentElement) {
                for (var currentIndex = 0; currentIndex < parentElement.children.length; currentIndex++) {
                    var childElement = parentElement.children[currentIndex];
                    var cellDetails = cellFromElement(childElement);
                    if (cellDetails.rowIndex === scrollToIndex) {
                        childElement.scrollIntoView(this.scrollToOptions);
                        break;
                    }
                }
            }
            this.scrollToIndex = -1;
            this.scrollToOptions = undefined;
        }
    };
    List.prototype.componentWillUnmount = function () {
        this.context.unregister(this.onIntersect);
    };
    List.prototype.addOverlay = function (id, rowIndex, render, zIndex) {
        if (zIndex === void 0) { zIndex = 0; }
        var overlays = this.state.overlays;
        var overlayIndex = overlays.value.findIndex(function (overlay) { return overlay.id === id; });
        var rowOverlay = { render: render, id: id, rowIndex: rowIndex, zIndex: zIndex + 1 };
        // Update the overlay if it exists for that id, otherwise add it
        if (overlayIndex >= 0) {
            overlays.change(overlayIndex, rowOverlay);
        }
        else {
            overlays.push(rowOverlay);
        }
    };
    List.prototype.removeOverlay = function (id) {
        var overlays = this.state.overlays;
        var overlayIndex = overlays.value.findIndex(function (overlay) { return overlay.id === id; });
        // Remove the overlay if it exists.
        if (overlayIndex >= 0) {
            overlays.splice(overlayIndex, 1);
        }
    };
    List.prototype.getFocusIndex = function () {
        return this.focusIndex;
    };
    List.prototype.scrollIntoView = function (rowIndex, options) {
        var _a = this.state, firstRow = _a.firstRow, lastRow = _a.lastRow;
        if (rowIndex >= 0 && rowIndex < this.state.rowCount) {
            var parentElement = this.bodyElement.current;
            // If the row is materialized, we will ensure it is in the viewport.
            if (rowIndex >= firstRow && rowIndex <= lastRow && parentElement) {
                for (var currentIndex = 0; currentIndex < parentElement.children.length; currentIndex++) {
                    var childElement = parentElement.children[currentIndex];
                    var cellDetails = cellFromElement(childElement);
                    if (cellDetails.rowIndex === rowIndex) {
                        childElement.scrollIntoView(options);
                        break;
                    }
                }
            }
            else {
                // Set the scrollToOptions that will be applied after the next update.
                this.scrollToIndex = rowIndex;
                this.scrollToOptions = options;
                // Update the visible range to include the requested row.
                this.setState({ firstRow: rowIndex, lastRow: rowIndex });
            }
        }
    };
    List.prototype.processSelectionEvent = function (event, listRow) {
        var selection = this.props.selection;
        if (!selection || selection.selectable(listRow.index)) {
            var initialState = false;
            var targetState = true;
            if (selection) {
                var index = listRow.index;
                // If a selection is available use it to track the initial state.
                initialState = selection.selected(index);
                // Determine the type of change being made to the selection based on key states.
                if (this.pivotIndex >= 0 && event.shiftKey && selection.multiSelect) {
                    selection.select(Math.min(this.pivotIndex, index), Math.abs(this.pivotIndex - index) + 1, event.ctrlKey || event.metaKey);
                }
                else {
                    if ((event.ctrlKey || event.metaKey || selection.alwaysMerge) && selection.multiSelect) {
                        selection.toggle(index, true);
                        targetState = false;
                    }
                    else {
                        selection.select(index, 1, false);
                    }
                }
                // Save the last selectionIndex that we selected, this will allow
                // us to perform range based selection.
                if (!event.shiftKey) {
                    this.pivotIndex = index;
                }
            }
            if (initialState !== targetState) {
                this.rowSelected(event, listRow);
            }
        }
    };
    List.prototype.renderLoadingRow = function (rowIndex, details) {
        return (React.createElement(ListItem, { className: "bolt-list-row-loading", details: details, index: rowIndex },
            React.createElement("div", { className: "shimmer shimmer-line", style: { width: Math.random() * 80 + 20 + "%" } }, "\u00A0")));
    };
    List.prototype.renderOverlay = function (listElementRef) {
        var _this = this;
        var _a = this.state, firstRow = _a.firstRow, lastRow = _a.lastRow, overlays = _a.overlays;
        return (React.createElement(Observer, { overlays: overlays }, function (props) {
            var bodyElement = _this.bodyElement.current;
            if (props.overlays.length > 0 && bodyElement) {
                return (React.createElement("div", { className: "bolt-list-overlay-container absolute" }, props.overlays.map(function (overlay) {
                    // Make sure the row is in the rendered range of rows before starting.
                    if (overlay.rowIndex < firstRow || overlay.rowIndex > lastRow) {
                        return null;
                    }
                    // Find the row for the given rowIndex
                    var rowElement = listElementRef.current &&
                        listElementRef.current.querySelector("[data-row-index='" + overlay.rowIndex + "']");
                    // We cant render the overlay if the row is paged out since we can't determine
                    // the location of the row.
                    if (rowElement) {
                        return (React.createElement("div", { className: "bolt-list-overlay flex-row absolute", id: getSafeId(overlay.id), key: overlay.id, style: {
                                height: rowElement.offsetHeight,
                                top: rowElement.getBoundingClientRect().top - bodyElement.getBoundingClientRect().top,
                                zIndex: overlay.zIndex * 10
                            } }, overlay.render({ rowElement: rowElement })));
                    }
                    return null;
                })));
            }
            return null;
        }));
    };
    List.prototype.renderRow = function (rowIndex) {
        var _this = this;
        var itemProvider = this.props.itemProvider;
        var _a = this.state, renderedRows = _a.renderedRows, rows = _a.rows;
        var renderedRow = renderedRows[rowIndex];
        if (!renderedRow) {
            var item_2 = rows[rowIndex];
            if (!item_2) {
                if (itemProvider.getItem) {
                    item_2 = itemProvider.getItem(rowIndex);
                }
                else {
                    item_2 = itemProvider.value[rowIndex];
                }
            }
            // @TODO: If there are no more rows, we need to handle an itemProvider with -1 length.
            if (!item_2) {
                return null;
            }
            // Save the current item in the item cache.
            rows[rowIndex] = item_2;
            var selection = this.props.selection;
            var selectionObservable = void 0;
            if (selection) {
                selectionObservable = {
                    observableValue: selection,
                    filter: function (selectedRanges) {
                        for (var _i = 0, selectedRanges_1 = selectedRanges; _i < selectedRanges_1.length; _i++) {
                            var selectionRange = selectedRanges_1[_i];
                            if (rowIndex >= selectionRange.beginIndex && rowIndex <= selectionRange.endIndex) {
                                return true;
                            }
                        }
                        return false;
                    }
                };
            }
            // console.log("render row - " + rowIndex);
            // Render the row, save it in the cache, and add it to the current page.
            renderedRow = (React.createElement(Observer, { item: item_2, key: rowIndex, selection: selectionObservable }, function (props) {
                var _a = _this.props, renderRow = _a.renderRow, defaultTabbableRow = _a.defaultTabbableRow, renderLoadingRow = _a.renderLoadingRow;
                var focusIndex = _this.focusIndex;
                var tabbableIndex = focusIndex >= 0 ? focusIndex : defaultTabbableRow;
                var rowItem = ObservableLike.getValue(item_2);
                var itemDetails = {
                    ariaBusy: !props.item,
                    eventDispatch: _this.state.eventDispatch,
                    data: rowItem,
                    listProps: _this.props,
                    onFocusItem: _this.onFocusItem,
                    excludeTabStop: tabbableIndex !== rowIndex
                };
                if (props.item) {
                    return renderRow(rowIndex, props.item, itemDetails);
                }
                else if (renderLoadingRow) {
                    return renderLoadingRow(rowIndex, itemDetails);
                }
                else {
                    return _this.renderLoadingRow(rowIndex, itemDetails);
                }
            }));
            // Save the row in our cache.
            this.state.renderedRows[rowIndex] = renderedRow;
        }
        return renderedRow;
    };
    List.prototype.renderSpacer = function (key, rowCount) {
        var _this = this;
        return (React.createElement("tr", { className: "bolt-list-row-spacer", key: key, ref: function (spacerElement) {
                var existingElement = _this.spacerElements[key];
                if (spacerElement) {
                    if (existingElement !== spacerElement) {
                        if (existingElement) {
                            _this.context.unobserve(spacerElement);
                        }
                        _this.context.observe(spacerElement);
                        _this.spacerElements[key] = spacerElement;
                    }
                }
                else if (existingElement) {
                    _this.context.unobserve(existingElement);
                    delete _this.spacerElements[key];
                }
            } },
            React.createElement("td", { className: "bolt-list-cell-spacer", colSpan: this.props.columnCount, style: { height: rowCount * this.state.rowHeight + "px" } })));
    };
    List.prototype.rowActivated = function (event, listRow) {
        this.state.eventDispatch.dispatchEvent(event, listRow, "activate");
        if (!event.defaultPrevented && this.props.onActivate) {
            this.props.onActivate(event, listRow);
        }
        event.preventDefault();
    };
    List.prototype.rowSelected = function (event, listRow) {
        this.state.eventDispatch.dispatchEvent(event, listRow, "select");
        if (!event.defaultPrevented && this.props.onSelect) {
            this.props.onSelect(event, listRow);
        }
    };
    List.prototype.rowFocused = function (event, listRow) {
        this.state.eventDispatch.dispatchEvent(event, listRow, "focus");
        if (this.props.onFocus) {
            this.props.onFocus(event, listRow);
        }
    };
    List.contextType = IntersectionContext;
    List.defaultProps = {
        columnCount: 1,
        defaultTabbableRow: 0,
        focuszoneProps: { direction: 2 /* Vertical */ },
        initialPageCount: 3,
        pageSize: 10,
        role: "listbox",
        singleClickActivation: false,
        virtualize: true
    };
    return List;
}(React.Component));
export { List };
var ScrollableList = /** @class */ (function (_super) {
    tslib_1.__extends(ScrollableList, _super);
    function ScrollableList() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.list = React.createRef();
        return _this;
    }
    ScrollableList.prototype.render = function () {
        return (React.createElement(Intersection, { rootMargin: window.innerHeight / 2 },
            React.createElement("div", { className: "flex-grow scroll-auto" },
                React.createElement(List, tslib_1.__assign({}, this.props, { ref: this.list })))));
    };
    ScrollableList.prototype.addOverlay = function (id, rowIndex, render, zIndex) {
        if (zIndex === void 0) { zIndex = 0; }
        if (this.list.current) {
            return this.list.current.addOverlay(id, rowIndex, render, zIndex);
        }
    };
    ScrollableList.prototype.removeOverlay = function (id) {
        if (this.list.current) {
            return this.list.current.removeOverlay(id);
        }
    };
    ScrollableList.prototype.getFocusIndex = function () {
        if (this.list.current) {
            return this.list.current.getFocusIndex();
        }
        return -1;
    };
    ScrollableList.prototype.scrollIntoView = function (rowIndex, scrollToOptions) {
        if (this.list.current) {
            return this.list.current.scrollIntoView(rowIndex, scrollToOptions);
        }
    };
    return ScrollableList;
}(React.Component));
export { ScrollableList };
var SimpleList = /** @class */ (function (_super) {
    tslib_1.__extends(SimpleList, _super);
    function SimpleList() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.list = React.createRef();
        _this.renderListItem = function (rowIndex, listCell, details) {
            return renderListItem(rowIndex, details, renderListCell(listCell));
        };
        return _this;
    }
    SimpleList.prototype.render = function () {
        var listProps = {
            className: this.props.className,
            columnCount: 1,
            eventDispatch: this.props.eventDispatch,
            focuszoneProps: this.props.focuszoneProps,
            id: this.props.id,
            initialPageCount: this.props.initialPageCount,
            itemProvider: this.props.itemProvider,
            onActivate: this.props.onActivate,
            onFocus: this.props.onFocus,
            onSelect: this.props.onSelect,
            renderRow: this.renderListItem,
            selection: this.props.selection,
            width: this.props.width,
            virtualize: this.props.virtualize
        };
        if (this.props.scrollable) {
            return React.createElement(ScrollableList, tslib_1.__assign({}, listProps, { ref: this.list }));
        }
        else {
            return React.createElement(List, tslib_1.__assign({}, listProps, { ref: this.list }));
        }
    };
    SimpleList.prototype.addOverlay = function (id, rowIndex, render, zIndex) {
        if (zIndex === void 0) { zIndex = 0; }
        if (this.list.current) {
            return this.list.current.addOverlay(id, rowIndex, render, zIndex);
        }
    };
    SimpleList.prototype.removeOverlay = function (id) {
        if (this.list.current) {
            return this.list.current.removeOverlay(id);
        }
    };
    SimpleList.prototype.getFocusIndex = function () {
        if (this.list.current) {
            return this.list.current.getFocusIndex();
        }
        return -1;
    };
    SimpleList.prototype.scrollIntoView = function (rowIndex, scrollToOptions) {
        if (this.list.current) {
            return this.list.current.scrollIntoView(rowIndex, scrollToOptions);
        }
    };
    return SimpleList;
}(React.Component));
export { SimpleList };
export function renderListItem(rowIndex, details, children) {
    return (React.createElement(ListItem, { details: details, index: rowIndex }, children));
}
var ListItem = /** @class */ (function (_super) {
    tslib_1.__extends(ListItem, _super);
    function ListItem() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.onFocus = function (event) {
            _this.props.details.onFocusItem(_this.props.index, event);
        };
        return _this;
    }
    ListItem.prototype.render = function () {
        var _this = this;
        var _a = this.props, children = _a.children, details = _a.details, index = _a.index, linkProps = _a.linkProps;
        var ariaBusy = details.ariaBusy, ariaLabel = details.ariaLabel, ariaPosInSet = details.ariaPosInSet, ariaSetSize = details.ariaSetSize, excludeFocusZone = details.excludeFocusZone;
        var _b = details.listProps, selection = _b.selection, singleClickActivation = _b.singleClickActivation;
        // If the row is being rendered as a link we will use an anchor, otherwise we will
        // use a standard table row.
        var RowType = linkProps ? "a" : "tr";
        var CellType = linkProps ? "div" : "td";
        // Build the set of props needed from the link to forward on to the row element.
        var linkForwardProps;
        if (linkProps) {
            linkForwardProps = {
                disabled: linkProps.disabled,
                href: linkProps.href,
                id: linkProps.id,
                rel: linkProps.rel,
                role: linkProps.role,
                target: linkProps.target
            };
        }
        return (React.createElement(FocusWithin, { onFocus: this.onFocus }, function (focusStatus) { return (React.createElement(FocusZoneContext.Consumer, null, function (rowContext) {
            return (React.createElement(FocusZone, { direction: 1 /* Horizontal */ },
                React.createElement(RowType, tslib_1.__assign({}, linkForwardProps, { "aria-busy": ariaBusy, "aria-label": ariaLabel, "aria-posinset": ariaPosInSet === undefined ? index + 1 : ariaPosInSet === null ? undefined : ariaPosInSet, "aria-selected": selection && selection.selected(index), "aria-setsize": ariaSetSize === undefined
                        ? _this.props.details.listProps.itemProvider.length
                        : ariaSetSize === null
                            ? undefined
                            : ariaSetSize, className: css(_this.props.className, "bolt-list-row", index === 0 && "first-row", linkProps && "bolt-link", selection && selection.selected(index) && "selected", focusStatus.hasFocus && "focused", singleClickActivation && "single-click-activation"), "data-focuszone": excludeFocusZone ? undefined : rowContext.focuszoneId, "data-row-index": index, tabIndex: getTabIndex(details), onBlur: focusStatus.onBlur, onFocus: focusStatus.onFocus, role: "listitem" }),
                    React.createElement(CellType, { className: "bolt-list-cell", "data-column-index": 0 },
                        React.createElement("div", { className: "bolt-list-cell-content flex-row" }, children)))));
        })); }));
    };
    return ListItem;
}(React.Component));
export { ListItem };
export function renderListCell(listCell) {
    var textClassName = undefined;
    var textContent = (React.createElement(Tooltip, { overflowOnly: true },
        React.createElement("span", { className: "text-ellipsis" }, typeof listCell === "string" || typeof listCell === "number" ? listCell : listCell.text)));
    var content = textContent;
    var classNames = css("bolt-list-cell-child flex-row flex-center");
    if (typeof listCell !== "string" && typeof listCell !== "number") {
        textClassName = listCell.textClassName;
        if (listCell.iconProps) {
            content = (React.createElement(React.Fragment, null,
                Icon(tslib_1.__assign({}, listCell.iconProps, { className: css("bolt-list-cell-child", listCell.iconProps.className) })),
                textContent));
        }
        if (listCell.href) {
            return (React.createElement(Link, { className: css(textClassName, classNames, "scroll-hidden"), href: listCell.href, excludeTabStop: true, subtle: true }, content));
        }
    }
    return React.createElement("span", { className: css(textClassName, classNames, "bolt-list-cell-text") }, content);
}
function getAttributeAsNumber(element, attributeName) {
    var attributeValue = element.getAttribute(attributeName);
    if (attributeValue) {
        return parseInt(attributeValue, 10);
    }
    return -1;
}
export function cellFromElement(element) {
    var attributeValue;
    var cellIndex = -1;
    var rowIndex = -1;
    var cellElement = null;
    while (element) {
        attributeValue = getAttributeAsNumber(element, "data-column-index");
        if (attributeValue !== -1) {
            cellIndex = attributeValue;
            cellElement = element;
        }
        attributeValue = getAttributeAsNumber(element, "data-row-index");
        if (attributeValue !== -1) {
            rowIndex = attributeValue;
            break;
        }
        // We have hit the root of the details list, dont look above this.
        if (element.classList.contains("bolt-list")) {
            element = null;
            break;
        }
        element = element.parentElement;
    }
    return {
        cellElement: cellElement,
        cellIndex: cellIndex,
        rowElement: element,
        rowIndex: rowIndex
    };
}
export function cellFromEvent(event) {
    return cellFromElement(event.target);
}
