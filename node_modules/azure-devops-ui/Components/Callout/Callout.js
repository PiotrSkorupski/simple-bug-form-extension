import * as tslib_1 from "tslib";
import "../../CommonImports";
import "../../Core/core.css";
import "./Callout.css";
import * as React from "react";
import { FocusWithin } from '../../FocusWithin';
import { FocusZone } from '../../FocusZone';
import { Portal } from '../../Portal';
import { css, getSafeId } from '../../Util';
import { position, updateLayout } from '../../Utilities/Position';
import { SurfaceContext } from '../../Surface';
var Callout = /** @class */ (function (_super) {
    tslib_1.__extends(Callout, _super);
    function Callout() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.calloutContent = React.createRef();
        return _this;
    }
    Callout.prototype.render = function () {
        var portalProps = this.props.portalProps;
        return (React.createElement(Portal, tslib_1.__assign({}, portalProps, { className: css(portalProps && portalProps.className, this.props.anchorElement && "bolt-layout-relative") }),
            React.createElement(CalloutContent, tslib_1.__assign({ ref: this.calloutContent }, this.props))));
    };
    Callout.prototype.componentWillUnmount = function () {
        // We need to let the content handle the WillUnmount before the Portal, this
        // will ensure the the callout can deal with unmounting content that still has
        // focus. Otherwise the root will be detached from the document and focus will
        // have moved to the body.
        if (this.calloutContent.current) {
            this.calloutContent.current.portalWillUnmount();
        }
    };
    Callout.prototype.updateLayout = function () {
        if (this.calloutContent.current) {
            this.calloutContent.current.updateLayout();
        }
    };
    Callout.defaultProps = {
        blurDismiss: false
    };
    return Callout;
}(React.Component));
export { Callout };
var CalloutContent = /** @class */ (function (_super) {
    tslib_1.__extends(CalloutContent, _super);
    function CalloutContent(props) {
        var _this = _super.call(this, props) || this;
        _this.calloutElement = React.createRef();
        _this.contentElement = React.createRef();
        _this.scrollListen = false;
        _this.scrollEvent = null;
        _this.onBlur = function () {
            _this.props.onDismiss && _this.props.onDismiss();
        };
        _this.onClick = function (event) {
            // If we click on the light dismiss div we will dismiss it.
            if (_this.props.lightDismiss && !event.defaultPrevented) {
                if (_this.props.onDismiss) {
                    _this.props.onDismiss();
                }
                event.preventDefault();
            }
        };
        _this.onKeyDown = function (event) {
            // If we press escape from within the callout this will dismiss it.
            if (_this.props.escDismiss && event.which === 27 /* escape */ && !event.defaultPrevented) {
                if (_this.props.onDismiss) {
                    _this.props.onDismiss();
                }
                event.preventDefault();
            }
        };
        _this.onResize = function () {
            _this.props.onDismiss && _this.props.onDismiss();
        };
        _this.onScroll = function (event) {
            if (_this.scrollListen) {
                _this.scrollEvent = event.nativeEvent;
            }
        };
        _this.onScrollDocument = function (event) {
            if (_this.scrollListen) {
                if (event === _this.scrollEvent) {
                    _this.scrollEvent = null;
                }
                else {
                    if (_this.props.onDismiss) {
                        _this.props.onDismiss();
                    }
                }
            }
        };
        // Track the element that had focus when we mounted.
        _this.focusElement = document.activeElement;
        return _this;
    }
    CalloutContent.prototype.render = function () {
        var _this = this;
        var _a = this.props, contentJustification = _a.contentJustification, contentLocation = _a.contentLocation, contentOrientation = _a.contentOrientation, contentSize = _a.contentSize, lightDismiss = _a.lightDismiss, modal = _a.modal, anchorElement = _a.anchorElement;
        var content;
        // If we have both a FocusWithin and a FocusZone we need to use the functional version
        // of the FocusWithin to allow the FocusZone to contain the content directly.
        if (this.props.blurDismiss && this.props.focuszoneProps) {
            content = (React.createElement(FocusWithin, { onBlur: this.onBlur, updateStateOnFocusChange: false }, function (props) { return (React.createElement(FocusZone, tslib_1.__assign({}, _this.props.focuszoneProps), _this.renderContent(props.onFocus, props.onBlur))); }));
        }
        else {
            content = this.renderContent();
            // Add the focus tracker to dismiss the callout if we are dismissing on blur.
            if (this.props.blurDismiss) {
                content = (React.createElement(FocusWithin, { onBlur: this.onBlur, updateStateOnFocusChange: false }, content));
            }
            // Add focus zone if focuszoneProperties are specified
            if (this.props.focuszoneProps) {
                content = React.createElement(FocusZone, tslib_1.__assign({}, this.props.focuszoneProps), content);
            }
        }
        var lightDismissDiv = lightDismiss ? (React.createElement("div", { className: css("absolute-fill bolt-light-dismiss", modal && "bolt-callout-modal"), onClick: this.onClick })) : null;
        // The callout is wrapped in a floating element in the portal.
        // If lightDismiss is enabled we will create an absolute-fill div to capture onClick events.
        return (React.createElement(SurfaceContext.Provider, { value: { background: 2 /* callout */ } },
            React.createElement("div", { className: "flex-row flex-grow" },
                React.createElement("div", { "aria-describedby": getSafeId(this.props.ariaDescribedBy), "aria-label": this.props.ariaLabel, "aria-labelledby": getSafeId(this.props.ariaLabelledBy), className: css(this.props.className, "bolt-callout absolute", contentLocation !== undefined && "absolute-fill", contentJustification === 0 /* Start */ && "justify-start", contentJustification === 1 /* Center */ && "justify-center", contentJustification === 2 /* End */ && "justify-end", contentLocation === 0 /* Start */ && "flex-start", contentLocation === 1 /* Center */ && "flex-center", contentLocation === 2 /* End */ && "flex-end", contentOrientation === 0 /* Column */ && "flex-column", contentOrientation !== 0 /* Column */ && "flex-row", modal && !lightDismiss && "bolt-callout-modal"), id: getSafeId(this.props.id), onKeyDown: this.onKeyDown, ref: this.calloutElement },
                    !anchorElement && lightDismissDiv,
                    content),
                !!anchorElement && lightDismissDiv)));
    };
    CalloutContent.prototype.componentDidMount = function () {
        this.updateLayout();
        // If this is an element relative layout we need to listen for scroll events
        // on the document and dismiss the callout if the scroll event didnt pass
        // through the callout.
        if (this.props.anchorElement) {
            window.addEventListener("resize", this.onResize);
            document.addEventListener("scroll", this.onScrollDocument, true);
            this.scrollListen = true;
        }
    };
    CalloutContent.prototype.componentDidUpdate = function () {
        if (this.props.updateLayout) {
            this.updateLayout();
        }
    };
    CalloutContent.prototype.componentWillUnmount = function () {
        if (this.scrollListen) {
            document.removeEventListener("scroll", this.onScrollDocument, true);
            window.removeEventListener("resize", this.onResize);
        }
    };
    CalloutContent.prototype.portalWillUnmount = function () {
        var contentElement = this.contentElement.current;
        var focusElement = this.focusElement;
        // If the callout has focus when unmounted we need to set focus back to the last element with focus.
        // Need to wait for next tick otherwise focus/blur events are not fired.
        if (focusElement && contentElement && contentElement.contains(document.activeElement)) {
            window.setTimeout(function () {
                // We need to make sure the active element is portal after the timeout.
                // It may have moved through other means before the timeout expires.
                // Set focus to the focusElement if our element contains focus, or if the focus has gone back to the document body
                if (contentElement.contains(document.activeElement) || document.activeElement === document.body || document.activeElement === null) {
                    focusElement.focus();
                }
            }, 0);
        }
    };
    CalloutContent.prototype.updateLayout = function () {
        if (this.props.contentLocation === undefined) {
            if (this.calloutElement.current) {
                // Position the element based on the initial layout parameters.
                position(this.calloutElement.current, this.props.calloutOrigin || { horizontal: "start" /* start */, vertical: "start" /* start */ }, this.props.anchorOffset, this.props.anchorElement, this.props.anchorOrigin, this.props.anchorPoint);
                // Now that the component is placed at the requested location, update
                // the layout if the caller didnt request a fixed layout.
                if (!this.props.fixedLayout) {
                    updateLayout(this.calloutElement.current, this.props.calloutOrigin || { horizontal: "start" /* start */, vertical: "start" /* start */ }, this.props.anchorOffset, this.props.anchorElement, this.props.anchorOrigin, this.props.anchorPoint);
                }
            }
        }
    };
    CalloutContent.prototype.renderContent = function (onFocus, onBlur) {
        var _a = this.props, contentJustification = _a.contentJustification, contentOrientation = _a.contentOrientation, contentSize = _a.contentSize;
        return (React.createElement("div", { className: css(this.props.contentClassName, "bolt-callout-content", this.props.contentShadow && "bolt-callout-shadow", contentJustification === 3 /* Stretch */ && "flex-grow", contentOrientation === 0 /* Column */ && "flex-column", contentOrientation === 1 /* Row */ && "flex-row", contentSize === 0 /* Small */ && "bolt-callout-small", contentSize === 1 /* Medium */ && "bolt-callout-medium", contentSize === 2 /* Large */ && "bolt-callout-large"), onBlur: onBlur, onFocus: onFocus, onScroll: this.onScroll, ref: this.contentElement, role: this.props.role || "dialog" }, this.props.children));
    };
    return CalloutContent;
}(React.Component));
