import * as tslib_1 from "tslib";
import "../../CommonImports";
import "../../Core/core.css";
import "./Dropdown.css";
import * as React from "react";
import { ObservableArray, ObservableLike, ObservableValue } from '../../Core/Observable';
import * as Utils_Accessibility from '../../Core/Util/Accessibility';
import { format } from '../../Core/Util/String';
import { Button, ExpandableButton } from '../../Button';
import { Callout } from '../../Callout';
import { FocusZone } from '../../FocusZone';
import { FilteredListSelection } from '../../List';
import { getListBoxItemsValue, getUnselectableRanges, ListBox, wrapListBoxItems } from '../../ListBox';
import { ItemsObserver, Observer } from '../../Observer';
import * as Resources from '../../Resources.Dropdown';
import { TextField } from '../../TextField';
import { css, getSafeId } from '../../Util';
import { DropdownSelection } from '../../Utilities/DropdownSelection';
import { getItemsValue } from '../../Utilities/Provider';
var dropdownId = 1;
var ITEMS_FOR_FILTER = 10;
var Dropdown = /** @class */ (function (_super) {
    tslib_1.__extends(Dropdown, _super);
    function Dropdown(props) {
        var _this = _super.call(this, props) || this;
        _this.expandableButton = React.createRef();
        _this.filterText = new ObservableValue("");
        _this.filteredItems = new ObservableArray();
        _this.filteredIndexMap = [];
        _this.collapse = function () {
            if (_this.expandableButton.current) {
                _this.expandableButton.current.collapse();
            }
        };
        _this.expand = function () {
            if (_this.expandableButton.current) {
                _this.expandableButton.current.expand();
            }
        };
        _this.onExpand = function () {
            if (_this.props.onExpand) {
                _this.props.onExpand();
            }
            _this.updateFilteredItems();
        };
        _this.onDismiss = function () {
            if (_this.expandableButton.current) {
                _this.expandableButton.current.collapse();
            }
            _this.filterText.value = "";
            if (_this.props.onFilterTextChanged) {
                _this.props.onFilterTextChanged(null, "");
            }
            _this.updateFilteredItems();
        };
        _this.renderDropdown = function (dropdown, dropdownId, anchorElement, anchorOffset, anchorOrigin, anchorPoint, dropdownOrigin) {
            var _a = _this.props, actions = _a.actions, calloutContentClassName = _a.calloutContentClassName, className = _a.className, containerClassName = _a.containerClassName, filteredItems = _a.filteredItems, filteredNoResultsText = _a.filteredNoResultsText, getUnselectableRanges = _a.getUnselectableRanges, items = _a.items, loading = _a.loading, onSelect = _a.onSelect, renderItem = _a.renderItem, searching = _a.searching, showFilterBox = _a.showFilterBox, width = _a.width;
            return (React.createElement(Callout, { anchorElement: anchorElement, anchorOffset: anchorOffset, anchorOrigin: anchorOrigin, anchorPoint: anchorPoint, blurDismiss: true, calloutOrigin: dropdownOrigin, contentClassName: css(calloutContentClassName, "bolt-dropdown flex-column custom-scrollbar v-scroll-auto h-scroll-hidden"), contentShadow: true, escDismiss: true, id: dropdownId, onDismiss: _this.onDismiss },
                React.createElement(FocusZone, { circularNavigation: true, defaultActiveElement: showFilterBox ? "#" + getSafeId(_this.textFieldId) : ".bolt-dropdown-container", direction: 2 /* Vertical */, focusOnMount: true },
                    React.createElement("div", { className: "bolt-dropdown-container", tabIndex: -1 },
                        React.createElement(Observer, { items: items }, function () {
                            var shouldShowFilterBox = showFilterBox === undefined ? items.length > ITEMS_FOR_FILTER : showFilterBox;
                            return shouldShowFilterBox ? (React.createElement("div", { className: "bolt-dropdown-filter-container" },
                                React.createElement(TextField, { className: "bolt-dropdown-filter", excludeTabStop: true, inputId: _this.textFieldId, onChange: _this.onFilterTextChanged, prefixIconProps: { iconName: "Search" }, value: _this.filterText }))) : null;
                        }),
                        React.createElement(Observer, { listBoxItems: { observableValue: items, filter: _this.updateFilteredItems }, userFilteredItems: { observableValue: filteredItems, filter: _this.updateFilteredItems }, filteredItems: _this.filteredItems }, function () {
                            var noItemsElement = null;
                            var noItemsText = "";
                            if (items.length === 0) {
                                noItemsText = _this.props.noItemsText;
                            }
                            else if (_this.filteredItems.length === 0 && _this.filterText.value !== "") {
                                noItemsText = format(filteredNoResultsText || Resources.NoFilterResults, _this.filterText.value);
                            }
                            if (noItemsText) {
                                noItemsElement = React.createElement("div", { className: "bolt-dropdown-no-items" }, noItemsText);
                            }
                            return (React.createElement(React.Fragment, null,
                                noItemsElement,
                                React.createElement(ListBox, { className: className, containerClassName: css("bolt-dropdown-list-box-container", containerClassName), excludeTabStop: true, focuszoneProps: null, getUnselectableRanges: getUnselectableRanges, items: _this.filteredItems.value, loading: loading, onActivate: _this.onActivate, onSelect: onSelect, renderItem: renderItem, searching: searching, selection: _this.filteredSelection, width: width })));
                        }),
                        React.createElement(Observer, { actions: actions }, function (props) {
                            return props.actions && props.actions.length ? (React.createElement("div", { className: "bolt-actions-container flex-column" }, ObservableLike.getValue(props.actions).map(function (actionProps, index) { return (React.createElement(Button, tslib_1.__assign({ key: actionProps.id || index, subtle: true, excludeTabStop: true }, actionProps))); }))) : null;
                        })))));
        };
        _this.onActivate = function (event, item) {
            if (!event.defaultPrevented && event.type === "keydown") {
                _this.filteredSelection.toggle(_this.filteredItems.value.indexOf(item), _this.filteredSelection.alwaysMerge);
                if (_this.props.onSelect) {
                    _this.props.onSelect(event, item);
                }
            }
        };
        _this.onFilterTextChanged = function (e, newValue) {
            _this.filterText.value = newValue;
            if (_this.props.onFilterTextChanged) {
                _this.props.onFilterTextChanged(e, newValue);
            }
            _this.updateFilteredItems();
        };
        _this.onSelect = function (value, action) {
            var selection = _this.parentSelection;
            if (selection.value.length > 0 && !selection.multiSelect && !selection.selectOnFocus) {
                _this.onDismiss();
            }
            _this.filteredSelection.selectionChanged(value, action);
            return true;
        };
        _this.updateFilteredItems = function () {
            _this.filteredIndexMap = [];
            var items = getListBoxItemsValue(_this.props.items, _this.wrappedItems);
            var filteredItems = items;
            if (_this.props.filteredItems) {
                filteredItems = getItemsValue(_this.props.filteredItems);
                for (var filteredIndex = 0; filteredIndex < _this.props.filteredItems.length; filteredIndex++) {
                    var index = items.indexOf(filteredItems[filteredIndex]);
                    if ($DEBUG) {
                        if (index === -1) {
                            console.error("filteredItems contains an item not in items. " +
                                "Selection cannot be maintained unless filteredItems is a subset of items. " +
                                "Check item in filteredItems at index " +
                                filteredIndex);
                        }
                    }
                    _this.filteredIndexMap.push(index);
                }
            }
            else {
                if (_this.filterText.value) {
                    filteredItems = [];
                    var currentGroup = "";
                    if (_this.props.filterItem) {
                        for (var i = items.length - 1; i >= 0; i--) {
                            // Add Dividers and Headers if they have an item from their group showing.
                            if ((items[i].type === 2 /* Header */ || items[i].type === 3 /* Divider */) &&
                                items[i].groupId &&
                                items[i].groupId === currentGroup) {
                                _this.filteredIndexMap.unshift(i);
                                filteredItems.unshift(items[i]);
                            }
                            if (_this.props.filterItem(_this.filterText.value, items[i], items)) {
                                _this.filteredIndexMap.unshift(i);
                                filteredItems.unshift(items[i]);
                                currentGroup = items[i].groupId;
                            }
                        }
                    }
                    // Remove the first item if it's a divider
                    while (filteredItems.length && filteredItems[0].type === 3 /* Divider */) {
                        filteredItems.shift();
                        _this.filteredIndexMap.shift();
                    }
                }
            }
            if (_this.filterText.value) {
                Utils_Accessibility.announce(filteredItems.length > 0 ? format(Resources.AnnounceFilterResultCount, filteredItems.length) : Resources.NoFilterResults, true);
            }
            _this.filteredItems.value = filteredItems;
            _this.filteredSelection.updateFilteredSelection(_this.filteredIndexMap);
            return true;
        };
        _this.parentSelection = props.selection || new DropdownSelection();
        _this.wrappedItems = wrapListBoxItems(props.items);
        var itemsValue = getListBoxItemsValue(props.items, _this.wrappedItems);
        _this.filteredItems.value = itemsValue.slice();
        _this.filteredSelection = new FilteredListSelection(_this.parentSelection);
        _this.textFieldId = "bolt-dropdown-textfield-" + dropdownId++;
        _this.state = { scrollBarWidth: 0 };
        return _this;
    }
    Dropdown.prototype.render = function () {
        var _this = this;
        var _a = this.props, ariaLabel = _a.ariaLabel, buttonClassName = _a.buttonClassName, hideDropdownIcon = _a.hideDropdownIcon, items = _a.items, labelClassName = _a.labelClassName, onClick = _a.onClick, onCollapse = _a.onCollapse, placeholder = _a.placeholder, renderSelectedItems = _a.renderSelectedItems;
        var selectionObservable = { observableValue: this.parentSelection, filter: this.onSelect };
        return (React.createElement(ItemsObserver, { getUnselectableRanges: this.props.getUnselectableRanges, items: items, selection: this.parentSelection },
            React.createElement(Observer, { selection: selectionObservable }, function () {
                var text = placeholder;
                if (_this.parentSelection.selectedCount > 0 && renderSelectedItems) {
                    text = renderSelectedItems(_this.parentSelection, getListBoxItemsValue(items, _this.wrappedItems));
                }
                return (React.createElement(ExpandableButton, { ariaLabel: ariaLabel, className: buttonClassName, hideDropdownIcon: hideDropdownIcon, onClick: onClick, onCollapse: onCollapse, onExpand: _this.onExpand, ref: _this.expandableButton, renderCallout: _this.renderDropdown },
                    React.createElement("div", { className: css(labelClassName, "justify-start flex-grow text-ellipsis") }, text)));
            })));
    };
    Dropdown.prototype.focus = function () {
        if (this.expandableButton.current) {
            this.expandableButton.current.focus();
        }
    };
    Dropdown.defaultProps = {
        renderSelectedItems: renderDropdownSelectedItemText,
        filterItem: filterItemByText,
        getUnselectableRanges: getUnselectableRanges
    };
    return Dropdown;
}(React.Component));
export { Dropdown };
export function filterItemByText(filterText, item) {
    if (item.text && item.type !== 2 /* Header */ && item.type !== 3 /* Divider */) {
        return item.text.toLowerCase().indexOf(filterText.toLowerCase()) !== -1;
    }
    return false;
}
export function renderDropdownSelectedItemText(selection, items) {
    var text = items[selection.value[0].beginIndex].text || "";
    if (selection.selectedCount > 1) {
        text = text + " (+" + (selection.selectedCount - 1) + ")";
    }
    return text;
}
