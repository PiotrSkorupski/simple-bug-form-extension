import * as tslib_1 from "tslib";
import "../../CommonImports";
import "../../Core/core.css";
import "./IdentityPicker.css";
import * as React from "react";
import { ObservableArray, ObservableLike, ObservableValue } from '../../Core/Observable';
import { TimerManagement } from '../../Core/TimerManagement';
import { IdentityCard } from '../../IdentityCard';
import { Observer } from '../../Observer';
import { Persona } from '../../Persona';
import * as Resources from '../../Resources.IdentityPicker';
import { TagPicker } from '../../TagPicker';
import { renderSuggestionItem } from "../IdentityPickerSuggestionsList/IdentityPickerSuggestionsListHelpers";
import { makeCancelable } from '../../Core/Util/Promise';
var IdentityPicker = /** @class */ (function (_super) {
    tslib_1.__extends(IdentityPicker, _super);
    function IdentityPicker(props) {
        var _this = _super.call(this, props) || this;
        _this.openedIdentityCard = new ObservableValue(undefined);
        _this.outerElement = React.createRef();
        _this.lastSearchVal = "";
        _this.suggestions = new ObservableArray([]);
        _this.suggestionsLoading = new ObservableValue(false);
        _this.areTagsEqual = function (first, second) {
            return first.entityId === second.entityId;
        };
        _this.renderSuggestionItem = function (suggestion) {
            return renderSuggestionItem(suggestion, _this.onOpenPersonaCard);
        };
        _this.onOpenPersonaCard = function (identity) {
            _this.openedIdentityCard.value = identity;
        };
        _this.onClosePersonaCard = function () {
            _this.openedIdentityCard.value = undefined;
        };
        _this.onEmptyInputFocus = function () {
            _this.updateSuggestionsList(_this.props.pickerProvider.onEmptyInputFocus());
        };
        _this.onAddIdentity = function (identity) {
            !!_this.props.pickerProvider.addIdentitiesToMRU && _this.props.pickerProvider.addIdentitiesToMRU([identity]);
            _this.props.onIdentityAdded(identity);
        };
        _this.convertItemToPill = function (person, index) {
            return {
                className: "bolt-identity-picker-pill flex-row",
                content: person.displayName,
                onRenderFilledVisual: function () {
                    return React.createElement(Persona, { className: "flex-row flex-center", identity: person, size: 2 /* extraSmallPlus */ });
                }
            };
        };
        _this.onResolveSuggestions = function (updatedValue) {
            _this.lastSearchVal = updatedValue;
            var suggestions = _this.props.pickerProvider.onFilterIdentities(updatedValue, ObservableLike.getValue(_this.props.selectedIdentities));
            if (suggestions !== null) {
                if (_this.cachedResults[updatedValue]) {
                    _this.suggestions.value = _this.cachedResults[updatedValue].filter(function (identity) {
                        return !ObservableLike.getValue(_this.props.selectedIdentities).some(function (selectedIdentity) { return selectedIdentity.entityId === identity.entityId; });
                    });
                }
                else {
                    _this.updateSuggestionsList(suggestions, updatedValue);
                }
            }
        };
        _this.cachedResults = {};
        _this.timerManagement = new TimerManagement();
        return _this;
    }
    IdentityPicker.prototype.render = function () {
        var _this = this;
        return (React.createElement("div", { ref: this.outerElement },
            React.createElement(Observer, { openedIdentityCard: this.openedIdentityCard }, function (props) {
                return (React.createElement(React.Fragment, null,
                    React.createElement(TagPicker, { suggestionsLoading: _this.suggestionsLoading, areTagsEqual: _this.areTagsEqual, convertItemToPill: _this.convertItemToPill, noResultsFoundText: Resources.IdentityPickerNoResultsText, onEmptyInputFocus: _this.onEmptyInputFocus, onSearchChanged: _this.onResolveSuggestions, onTagAdded: _this.onAddIdentity, onTagRemoved: _this.props.onIdentityRemoved, onTagsRemoved: _this.props.onIdentitiesRemoved, placeholderText: _this.props.placeholderText || Resources.MultiIdentityPickerPlaceholderText, prefixIconProps: {
                            className: "bolt-identity-picker-contact-icon justify-center fontSizeML flex-center",
                            iconName: "Contact"
                        }, renderSuggestionItem: _this.renderSuggestionItem, selectedTags: _this.props.selectedIdentities, suggestions: _this.suggestions, suggestionsLoadingText: Resources.Loading }),
                    props.openedIdentityCard && (React.createElement(IdentityCard, { getEntityFromUniqueAttribute: _this.props.pickerProvider.getEntityFromUniqueAttribute, key: props.openedIdentityCard.entityId, identity: props.openedIdentityCard, displayName: props.openedIdentityCard.displayName, target: _this.outerElement.current, onDismissCallback: _this.onClosePersonaCard, onRequestConnectionInformation: _this.props.pickerProvider.onRequestConnectionInformation }))));
            })));
    };
    IdentityPicker.prototype.componentDidMount = function () {
        this.onResolveSuggestions = this.timerManagement.debounce(this.onResolveSuggestions, 250);
    };
    IdentityPicker.prototype.componentWillUnmount = function () {
        this.currentPromise && this.currentPromise.cancel();
    };
    IdentityPicker.prototype.updateSuggestionsList = function (suggestions, initialSearchValue) {
        var _this = this;
        var suggestionsArray = suggestions;
        var suggestionsPromiseLike = suggestions;
        // Check to see if the returned value is an array, if it is then just pass it into the next function.
        // If the returned value is not an array then check to see if it's a promise or PromiseLike. If it is then resolve it asynchronously.
        if (Array.isArray(suggestionsArray)) {
            this.suggestions.value = suggestionsArray.filter(function (identity) {
                return !ObservableLike.getValue(_this.props.selectedIdentities).some(function (selectedIdentity) { return selectedIdentity.entityId === identity.entityId; });
            });
        }
        else if (suggestionsPromiseLike && suggestionsPromiseLike.then) {
            if (!this.loadingTimer) {
                this.loadingTimer = this.timerManagement.setTimeout(function () {
                    _this.suggestionsLoading.value = true;
                }, 100);
            }
            // Ensure that the promise will only use the callback if it was the most recent one.
            var promise_1 = (this.currentPromise = makeCancelable(suggestionsPromiseLike));
            promise_1.promise.then(function (newSuggestions) {
                if (promise_1 === _this.currentPromise) {
                    _this.suggestionsLoading.value = false;
                    // Only update the suggestion list if the search value hasn't changed
                    if (!initialSearchValue || _this.lastSearchVal === initialSearchValue) {
                        _this.suggestions.value = newSuggestions.filter(function (identity) {
                            return !ObservableLike.getValue(_this.props.selectedIdentities).some(function (selectedIdentity) { return selectedIdentity.entityId === identity.entityId; });
                        });
                    }
                    if (!!initialSearchValue && initialSearchValue !== "" && _this.suggestions.value && _this.suggestions.value.length > 0) {
                        _this.cachedResults[initialSearchValue] = newSuggestions;
                    }
                    if (_this.loadingTimer) {
                        _this.timerManagement.clearTimeout(_this.loadingTimer);
                        _this.loadingTimer = undefined;
                    }
                }
            });
        }
    };
    return IdentityPicker;
}(React.Component));
export { IdentityPicker };
