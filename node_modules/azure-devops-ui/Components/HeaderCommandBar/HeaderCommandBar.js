import * as tslib_1 from "tslib";
import "../../CommonImports";
import "../../Core/core.css";
import "./HeaderCommandBar.css";
import * as React from "react";
import { Button } from '../../Button';
import { MenuButton, MoreButton } from '../../Menu';
import { css } from '../../Util';
import { FILTER_CHANGE_EVENT } from '../../Utilities/Filter';
import { ObservableArray } from '../../Core/Observable';
import { CustomHeaderCommandBar } from "./CustomHeaderCommandBar";
import { getFilterItem } from "./Items";
var headerCommandBarId = 1;
var HeaderCommandBar = /** @class */ (function (_super) {
    tslib_1.__extends(HeaderCommandBar, _super);
    function HeaderCommandBar(props) {
        var _this = _super.call(this, props) || this;
        _this.menuButtonId = "header-command-bar-menu-button" + headerCommandBarId++;
        return _this;
    }
    HeaderCommandBar.prototype.render = function () {
        var items = this.props.items;
        var buttonItems = [];
        var overflowItems = [];
        // Anything with important: true will be rendered as a button
        // Anything with important: false will be rendered in overflow
        // If there are less than 3 important items, items from the front of
        // the list will be rendered as button until we have 3.
        // The rest will be rendered in overflow.
        var importantCount = items.filter(function (item) { return item.important === true; }).length;
        var spaceRemainingForUnimporantItems = 3 - importantCount;
        var lastItemIsIconButton = false;
        for (var i = 0; i < items.length; i++) {
            var item = items[i];
            if (item.important) {
                lastItemIsIconButton = item.iconProps && !item.text ? true : false;
                buttonItems.push(item);
            }
            else if (spaceRemainingForUnimporantItems > 0 && item.important === undefined) {
                spaceRemainingForUnimporantItems--;
                lastItemIsIconButton = item.iconProps && !item.text ? true : false;
                buttonItems.push(item);
            }
            else {
                overflowItems.push(item);
            }
        }
        var setSize = buttonItems.length + (overflowItems.length > 0 ? 1 : 0);
        lastItemIsIconButton = lastItemIsIconButton || overflowItems.length > 0;
        var buttons = (React.createElement(React.Fragment, null,
            buttonItems.map(function (value, index) {
                var id = value.id;
                var buttonProps = {
                    ariaLabel: value.ariaLabel,
                    ariaPosInSet: index + 1,
                    ariaSetSize: setSize,
                    className: css(value.className, "bolt-header-command-item-button"),
                    disabled: value.disabled,
                    href: value.href,
                    iconProps: value.iconProps && { iconName: value.iconProps.iconName },
                    id: id,
                    primary: value.isPrimary,
                    role: value.role || "menuitem",
                    subtle: value.subtle,
                    target: value.target,
                    text: value.text,
                    tooltipProps: value.tooltipProps
                };
                var TagName = Button;
                if (value.subMenuProps) {
                    buttonProps.contextualMenuProps = { menuProps: value.subMenuProps };
                    buttonProps.hideDropdownIcon = value.hideDropdownIcon;
                    TagName = MenuButton;
                }
                else {
                    buttonProps.onClick = function (e) { return value.onActivate && value.onActivate(value, e); };
                }
                return React.createElement(TagName, tslib_1.__assign({}, buttonProps, { key: id }));
            }),
            overflowItems.length > 0 && (React.createElement(MoreButton, { ariaPosInSet: buttonItems.length + 1, ariaSetSize: setSize, className: "bolt-header-command-item-button", contextualMenuProps: {
                    menuProps: { id: "header-submenu", items: new ObservableArray(overflowItems) }
                }, id: this.menuButtonId, role: "menuitem" }))));
        // We will use a role of "menubar", unless the first item has a role of button.
        // This will be the case the close button in Panel Headers.
        return items.length > 0 ? (React.createElement(CustomHeaderCommandBar, { className: this.props.className, focusGroupProps: { defaultElementId: buttonItems.length ? buttonItems[0].id : this.menuButtonId }, lastItemIsIconButton: true, role: buttonItems.length && buttonItems[0].role === "button" ? undefined : "menubar" }, buttons)) : null;
    };
    return HeaderCommandBar;
}(React.Component));
export { HeaderCommandBar };
var HeaderCommandBarWithFilter = /** @class */ (function (_super) {
    tslib_1.__extends(HeaderCommandBarWithFilter, _super);
    function HeaderCommandBarWithFilter(props) {
        var _this = _super.call(this, props) || this;
        _this.onFilterClicked = function () {
            _this.props.filterToggled.value = !_this.props.filterToggled.value;
        };
        _this.onFilterChanged = function () {
            var hasChanges = _this.props.filter.hasChangesToReset();
            if (hasChanges !== _this.state.filterHasChanges) {
                _this.setState({
                    filterHasChanges: hasChanges
                });
            }
        };
        _this.state = { filterHasChanges: _this.props.filter.hasChangesToReset() };
        return _this;
    }
    HeaderCommandBarWithFilter.prototype.componentDidMount = function () {
        this.props.filter.subscribe(this.onFilterChanged, FILTER_CHANGE_EVENT);
    };
    HeaderCommandBarWithFilter.prototype.componentWillUnmount = function () {
        this.props.filter.unsubscribe(this.onFilterChanged, FILTER_CHANGE_EVENT);
    };
    HeaderCommandBarWithFilter.prototype.render = function () {
        var items = this.props.items ? this.props.items.slice() : [];
        items.push(getFilterItem(this.onFilterClicked, this.state.filterHasChanges));
        return React.createElement(HeaderCommandBar, tslib_1.__assign({}, this.props, { items: items }));
    };
    return HeaderCommandBarWithFilter;
}(React.Component));
export { HeaderCommandBarWithFilter };
