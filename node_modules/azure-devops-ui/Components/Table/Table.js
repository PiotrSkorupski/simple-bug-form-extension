import * as tslib_1 from "tslib";
import "../../CommonImports";
import "../../Core/core.css";
import "./Table.css";
import * as React from "react";
import * as Resources from '../../Resources.Widgets';
import { ObservableLike } from '../../Core/Observable';
import { FocusWithin } from '../../FocusWithin';
import { FocusZone, FocusZoneContext } from '../../FocusZone';
import { Icon } from '../../Icon';
import { Intersection } from '../../Intersection';
import { List, renderListCell } from '../../List';
import { Observer } from '../../Observer';
import { Sizer } from '../../Sizer';
import { css } from '../../Util';
import { EventDispatch } from '../../Utilities/Dispatch';
import { getTabIndex } from '../../Utilities/Focus';
/**
 * ColumnFill is used to fill the remaining space in the parent element with an
 * empty column. This column can be used anywhere in the column order. Columns
 * that appear after this will be pushed to the right.
 */
export var ColumnFill = {
    columnLayout: 0 /* none */,
    id: "_fill",
    renderCell: function (rowIndex, columnIndex) {
        return (React.createElement("td", { key: "col-fill", "aria-colindex": columnIndex, className: css("bolt-table-cell bolt-list-cell", "col-" + columnIndex), "data-column-index": columnIndex }));
    },
    renderHeaderCell: function (columnIndex, tableColumn) {
        return (React.createElement("td", { key: "col-fill", className: css(tableColumn.headerClassName, "bolt-table-header-cell bolt-table-header-cell-empty", "col-header-" + columnIndex), "data-column-index": columnIndex }));
    },
    width: -100
};
/**
 * The Table is a multi-column List component with an optional header.
 */
var Table = /** @class */ (function (_super) {
    tslib_1.__extends(Table, _super);
    function Table(props) {
        var _this = _super.call(this, props) || this;
        // Reference to the underlying list interface.
        _this.list = React.createRef();
        _this.onColumnsChanged = function () {
            _this.forceUpdate();
            return false;
        };
        _this.renderHeader = function () {
            var _a = _this.props, columns = _a.columns, showHeader = _a.showHeader, renderHeader = _a.renderHeader, spacerWidth = _a.spacerWidth;
            var widths = [];
            var proportionalTotal = 0;
            // Determine the percentage for proportionally sized columns.
            for (var columnIndex = 0; columnIndex < columns.length; columnIndex++) {
                var width = ObservableLike.getValue(columns[columnIndex].width);
                if (width < 0) {
                    proportionalTotal += width;
                }
            }
            // Compute the width of all columns based on the fixed/proportional values
            for (var columnIndex = 0; columnIndex < columns.length; columnIndex++) {
                var width = ObservableLike.getValue(columns[columnIndex].width);
                widths[columnIndex] = width >= 0 ? width : -((width / proportionalTotal) * 100);
            }
            return (React.createElement(React.Fragment, null,
                React.createElement("colgroup", null,
                    React.createElement("col", { key: "col-group-left-spacer", style: { width: spacerWidth === 0 ? spacerWidth + "%" : spacerWidth + "px" } }),
                    columns.map(function (column, columnIndex) {
                        return (React.createElement(Observer, { key: "col-group-" + columnIndex, width: {
                                filter: _this.onColumnsChanged,
                                observableValue: column.width
                            } }, function () { return React.createElement("col", { style: { width: Math.abs(widths[columnIndex]) + (widths[columnIndex] < 0 ? "%" : "px") } }); }));
                    }),
                    React.createElement("col", { key: "col-group-right-spacer", style: { width: spacerWidth === 0 ? spacerWidth + "%" : spacerWidth + "px" } })),
                showHeader ? renderHeader ? renderHeader(columns) : React.createElement(TableHeader, { tableColumns: columns }) : null));
        };
        _this.renderLoadingRow = function (rowIndex, details) {
            var _a = _this.props, columns = _a.columns, renderLoadingRow = _a.renderLoadingRow;
            var rowDetails = {
                ariaBusy: true,
                data: details.data,
                eventDispatch: _this.state.eventDispatch,
                excludeTabStop: details.excludeTabStop,
                itemProvider: _this.props.itemProvider,
                listProps: details.listProps,
                onFocusItem: details.onFocusItem,
                renderSpacer: _this.props.renderSpacer,
                selection: _this.props.selection,
                singleClickActivation: _this.props.singleClickActivation
            };
            // If a custom row loading animation is available use it.
            if (renderLoadingRow) {
                return renderLoadingRow(rowIndex, rowDetails);
            }
            // Return the default row loading animation.
            return (React.createElement(TableRow, { className: "bolt-list-row-loading", details: rowDetails, index: rowIndex }, columns.map(function (column, columnIndex) {
                return SimpleTableCell({ columnIndex: columnIndex, children: renderLoadingCell(column.columnLayout) });
            })));
        };
        _this.renderRow = function (rowIndex, item, details) {
            var rowDetails = {
                eventDispatch: _this.state.eventDispatch,
                data: details.data,
                excludeTabStop: details.excludeTabStop,
                itemProvider: _this.props.itemProvider,
                listProps: details.listProps,
                onFocusItem: details.onFocusItem,
                renderSpacer: _this.props.renderSpacer,
                selection: _this.props.selection,
                singleClickActivation: _this.props.singleClickActivation
            };
            // First determine if the item supplied a custom row rendering function, if not
            // attempt to use the global row rendering function.
            var renderRow = item.renderRow || _this.props.renderRow;
            if (renderRow) {
                return renderRow(rowIndex, item, rowDetails);
            }
            // If no custom row renderer is available use the default row renderer.
            return (React.createElement(TableRow, { details: rowDetails, index: rowIndex }, _this.props.columns.map(function (tableColumn, columnIndex) {
                return tableColumn.renderCell(rowIndex, columnIndex, tableColumn, item);
            })));
        };
        _this.state = {
            columnBehaviors: [],
            tableBehaviors: [],
            eventDispatch: props.eventDispatch || new EventDispatch(),
            tableWidth: ""
        };
        // Initialize any column behaviors.
        for (var columnIndex = 0; columnIndex < props.columns.length; columnIndex++) {
            var tableColumn = props.columns[columnIndex];
            if (tableColumn.behaviors) {
                for (var _i = 0, _a = tableColumn.behaviors; _i < _a.length; _i++) {
                    var behavior = _a[_i];
                    if (behavior && behavior.initialize) {
                        behavior.initialize({ tableProps: props, columnIndex: columnIndex }, {}, _this.state.eventDispatch);
                    }
                }
            }
        }
        // Initialize the supplied behaviors.
        if (props.behaviors) {
            for (var _b = 0, _c = props.behaviors; _b < _c.length; _b++) {
                var behavior = _c[_b];
                if (behavior.initialize) {
                    behavior.initialize(props, _this, _this.state.eventDispatch);
                }
            }
        }
        return _this;
    }
    Table.getDerivedStateFromProps = function (props, state) {
        var tableBehaviors = [];
        var columnBehaviors = [];
        // Build the set of behaviors columns have attached to them
        for (var columnIndex = 0; columnIndex < props.columns.length; columnIndex++) {
            var tableColumn = props.columns[columnIndex];
            if (tableColumn.behaviors) {
                for (var _i = 0, _a = tableColumn.behaviors; _i < _a.length; _i++) {
                    var behavior = _a[_i];
                    columnBehaviors.push(behavior);
                }
            }
        }
        // Build the set of behaviors the table has attached to it
        if (props.behaviors) {
            tableBehaviors.splice.apply(tableBehaviors, [tableBehaviors.length, 0].concat(props.behaviors));
        }
        return {
            columnBehaviors: columnBehaviors,
            tableBehaviors: tableBehaviors
        };
    };
    Table.prototype.render = function () {
        var eventDispatch = this.state.eventDispatch;
        var _a = this.props, className = _a.className, columns = _a.columns, containerClassName = _a.containerClassName, focuszoneProps = _a.focuszoneProps, showLines = _a.showLines, id = _a.id, itemProvider = _a.itemProvider, onActivate = _a.onActivate, onFocus = _a.onFocus, onSelect = _a.onSelect, pageSize = _a.pageSize, role = _a.role, rowHeight = _a.rowHeight, scrollable = _a.scrollable, selection = _a.selection, singleClickActivation = _a.singleClickActivation, virtualize = _a.virtualize;
        var spacerWidth = (this.props.spacerWidth || 0) * 2;
        var tableMaxWidth = spacerWidth;
        var tableMinWidth = spacerWidth;
        var tableWidth = spacerWidth;
        var constrain = false;
        var fill = false;
        // Compute the table size based on the current column definition. Size the sizes
        // are observable, we need to recompute each render to ensure we have the
        // proper values.
        for (var _i = 0, columns_1 = columns; _i < columns_1.length; _i++) {
            var column = columns_1[_i];
            var maxWidth = column.maxWidth, minWidth = column.minWidth;
            var width = ObservableLike.getValue(column.width);
            if (width < 0) {
                // This is a variable width columnn so we will fill the container.
                fill = true;
                // Update the min/max width of the table based on the supplied value.
                // We use a minumum width of 100px if one isnt specified.
                tableMinWidth += minWidth ? minWidth : 0;
                // If we have a variable width column, we will constrain the width by the sum
                // of the fixed width columns and the maxWidth of the variable width columns.
                if (maxWidth) {
                    constrain = true;
                    tableMaxWidth += maxWidth;
                }
            }
            else {
                tableWidth += width;
                tableMinWidth += width;
                tableMaxWidth += width;
            }
        }
        var listProps = {
            className: css(className, "bolt-table", showLines && "bolt-table-show-lines"),
            columnCount: columns.length + 2,
            eventDispatch: eventDispatch,
            focuszoneProps: focuszoneProps,
            id: id,
            itemProvider: itemProvider,
            maxWidth: constrain ? tableMaxWidth + "px" : undefined,
            minWidth: tableMinWidth !== tableWidth ? tableMinWidth + "px" : undefined,
            onActivate: onActivate,
            onFocus: onFocus,
            onSelect: onSelect,
            pageSize: pageSize,
            renderHeader: this.renderHeader,
            renderLoadingRow: this.renderLoadingRow,
            renderRow: this.renderRow,
            role: role,
            rowHeight: rowHeight,
            selection: selection,
            singleClickActivation: singleClickActivation,
            virtualize: virtualize,
            width: fill ? "100%" : tableWidth + "px"
        };
        var table = (React.createElement("div", { className: css(containerClassName, "bolt-table-container flex-grow", scrollable && "scroll-auto") },
            React.createElement(List, tslib_1.__assign({}, listProps, { ref: this.list }))));
        if (scrollable) {
            table = React.createElement(Intersection, { rootMargin: window.innerHeight / 2 }, table);
        }
        return table;
    };
    Table.prototype.componentDidMount = function () {
        // Mount any of the attached tableBehaviors.
        for (var _i = 0, _a = this.state.tableBehaviors; _i < _a.length; _i++) {
            var behavior = _a[_i];
            if (behavior.componentDidMount) {
                behavior.componentDidMount(this.props);
            }
        }
        for (var _b = 0, _c = this.state.columnBehaviors; _b < _c.length; _b++) {
            var behavior = _c[_b];
            if (behavior.componentDidMount) {
                behavior.componentDidMount({ tableProps: this.props });
            }
        }
    };
    Table.prototype.componentDidUpdate = function () {
        // Update any of the attached tableBehaviors.
        for (var _i = 0, _a = this.state.tableBehaviors; _i < _a.length; _i++) {
            var behavior = _a[_i];
            if (behavior.componentDidUpdate) {
                behavior.componentDidUpdate(this.props);
            }
        }
        for (var _b = 0, _c = this.state.columnBehaviors; _b < _c.length; _b++) {
            var behavior = _c[_b];
            if (behavior.componentDidUpdate) {
                behavior.componentDidUpdate({ tableProps: this.props });
            }
        }
    };
    Table.prototype.componentWillUnmount = function () {
        // Unmount any of the attached tableBehaviors.
        for (var _i = 0, _a = this.state.tableBehaviors; _i < _a.length; _i++) {
            var behavior = _a[_i];
            if (behavior.componentWillUnmount) {
                behavior.componentWillUnmount();
            }
        }
        for (var _b = 0, _c = this.state.columnBehaviors; _b < _c.length; _b++) {
            var behavior = _c[_b];
            if (behavior.componentDidUpdate) {
                behavior.componentDidUpdate({ tableProps: this.props });
            }
        }
    };
    Table.prototype.addOverlay = function (id, rowIndex, render, zIndex) {
        if (zIndex === void 0) { zIndex = 0; }
        if (this.list.current) {
            return this.list.current.addOverlay(id, rowIndex, render, zIndex);
        }
    };
    Table.prototype.removeOverlay = function (id) {
        if (this.list.current) {
            return this.list.current.removeOverlay(id);
        }
    };
    Table.prototype.getFocusIndex = function () {
        if (this.list.current) {
            return this.list.current.getFocusIndex();
        }
        return -1;
    };
    Table.prototype.scrollIntoView = function (rowIndex, options) {
        if (this.list.current) {
            return this.list.current.scrollIntoView(rowIndex, options);
        }
    };
    Table.defaultProps = {
        role: "grid",
        showHeader: true,
        showLines: true,
        singleClickActivation: true,
        spacerWidth: 8
    };
    return Table;
}(React.Component));
export { Table };
var TableHeader = /** @class */ (function (_super) {
    tslib_1.__extends(TableHeader, _super);
    function TableHeader() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    TableHeader.prototype.render = function () {
        var _this = this;
        return (React.createElement(FocusZoneContext.Consumer, null, function (rowContext) {
            return (React.createElement(FocusZone, { direction: 1 /* Horizontal */ },
                React.createElement("thead", null,
                    React.createElement(FocusWithin, null, function (focusStatus) {
                        return (React.createElement("tr", { className: css("bolt-table-header-row", focusStatus.hasFocus && "focused"), "data-row-index": -1, onBlur: focusStatus.onBlur, onFocus: focusStatus.onFocus },
                            React.createElement("td", { key: "left-spacer", role: "presentation" }),
                            _this.props.tableColumns.map(function (column, columnIndex) {
                                if (column.renderHeaderCell) {
                                    return column.renderHeaderCell(columnIndex, column, rowContext.focuszoneId);
                                }
                                else if (column.iconProps || column.name) {
                                    return (React.createElement(TableHeaderCell, { key: "col-header-" + columnIndex, column: column, columnIndex: columnIndex, focuszoneId: rowContext.focuszoneId },
                                        React.createElement("div", { className: "bolt-table-header-cell-text text-ellipsis" },
                                            column.iconProps && Icon(column.iconProps),
                                            column.name)));
                                }
                                else {
                                    return React.createElement("td", { key: "col-header-" + columnIndex });
                                }
                            }),
                            React.createElement("td", { key: "right-spacer", role: "presentation" })));
                    }),
                    React.createElement("tr", { className: "bolt-table-header-row", "data-row-index": -1 },
                        React.createElement("td", { key: "left-spacer", className: "bolt-table-header-spacer", role: "presentation" }),
                        _this.props.tableColumns.map(function (column, columnIndex) {
                            return (React.createElement("td", { key: "col-header-" + columnIndex, className: css("bolt-table-header-spacer", "col-header-" + columnIndex), role: "presentation" }));
                        }),
                        React.createElement("td", { key: "right-spacer", className: "bolt-table-header-spacer", role: "presentation" })))));
        }));
    };
    return TableHeader;
}(React.Component));
var TableHeaderCell = /** @class */ (function (_super) {
    tslib_1.__extends(TableHeaderCell, _super);
    function TableHeaderCell() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.element = React.createRef();
        _this.state = { measuredWidth: 0 };
        _this.onSize = function (event, updatedSize) {
            var column = _this.props.column;
            // Ensure we havent had our column definition updated and onSize removed.
            if (column.onSize) {
                column.onSize(event, _this.props.columnIndex, updatedSize, column);
            }
        };
        return _this;
    }
    TableHeaderCell.prototype.render = function () {
        var _this = this;
        var _a = this.props, column = _a.column, columnIndex = _a.columnIndex, focuszoneId = _a.focuszoneId;
        var sizer;
        if (column.onSize) {
            sizer = (React.createElement(Observer, { width: column.width }, function (props) {
                // If we are sizable we will either use the supplied width (desired), or the
                // measured width if we are a proportional column.
                var width = props.width;
                if (width < 0) {
                    width = _this.state.measuredWidth;
                }
                return (React.createElement(Sizer, { className: "bolt-table-header-sizer", divider: false, maxSize: column.maxWidth, minSize: column.minWidth, onSize: _this.onSize, onSizeEnd: _this.props.column.onSizeEnd, orientation: 0 /* row */, position: 0 /* near */, size: width }));
            }));
        }
        return (React.createElement(FocusZoneContext.Consumer, null, function (cellContext) {
            var actionable = (column.behaviors && column.behaviors.length > 0) || !!column.sortProps;
            var _a = column.sortProps, sortProps = _a === void 0 ? {} : _a;
            var _b = sortProps.ariaLabelAscending, ariaLabelAscending = _b === void 0 ? Resources.SortedAscending : _b, _c = sortProps.ariaLabelDescending, ariaLabelDescending = _c === void 0 ? Resources.SortedDescending : _c;
            return (React.createElement("td", { className: css(column.headerClassName, "bolt-table-header-cell", "col-header-" + columnIndex), "data-column-index": columnIndex, ref: _this.element, role: "columnheader" },
                React.createElement("div", { className: css("bolt-table-header-cell-content flex-row", actionable && "bolt-table-header-cell-actionable"), "data-focuszone": actionable && css(columnIndex === 0 && focuszoneId, cellContext.focuszoneId), tabIndex: actionable ? (columnIndex === 0 ? 0 : -1) : -1 },
                    sizer,
                    _this.props.children,
                    column.sortProps && sortProps.sortOrder !== undefined
                        ? Icon({
                            ariaLabel: sortProps.sortOrder === 0 /* ascending */ ? ariaLabelAscending : ariaLabelDescending,
                            className: "bolt-table-header-sort-icon",
                            iconName: sortProps.sortOrder === 0 /* ascending */ ? "SortUp" : "SortDown"
                        })
                        : null)));
        }));
    };
    TableHeaderCell.prototype.componentDidMount = function () {
        this.updateMeasuredWidth();
    };
    TableHeaderCell.prototype.componentDidUpdate = function () {
        this.updateMeasuredWidth();
    };
    TableHeaderCell.prototype.updateMeasuredWidth = function () {
        var column = this.props.column;
        if (column.onSize && this.element.current && ObservableLike.getValue(column.width) < 0) {
            var measuredWidth = this.element.current.getBoundingClientRect().width;
            if (measuredWidth !== this.state.measuredWidth) {
                this.setState({ measuredWidth: measuredWidth });
            }
        }
    };
    return TableHeaderCell;
}(React.Component));
export { TableHeaderCell };
var TableRow = /** @class */ (function (_super) {
    tslib_1.__extends(TableRow, _super);
    function TableRow() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.rowElement = React.createRef();
        _this.onFocus = function (event) {
            _this.props.details.onFocusItem(_this.props.index, event);
        };
        _this.onPostprocessKeyStroke = function (event) {
            if (!event.defaultPrevented) {
                if (event.which === 37 /* leftArrow */ && _this.rowElement.current) {
                    _this.rowElement.current.focus();
                    event.preventDefault();
                }
            }
            return 1 /* IgnoreNone */;
        };
        return _this;
    }
    TableRow.prototype.render = function () {
        var _this = this;
        var _a = this.props, details = _a.details, index = _a.index;
        var ariaLabel = details.ariaLabel, ariaBusy = details.ariaBusy, excludeFocusZone = details.excludeFocusZone, renderSpacer = details.renderSpacer, role = details.role, selection = details.selection, singleClickActivation = details.singleClickActivation;
        return (React.createElement(FocusWithin, { onFocus: this.onFocus }, function (focusStatus) {
            return (React.createElement(FocusZoneContext.Consumer, null, function (rowContext) {
                return (React.createElement(FocusZone, { direction: 1 /* Horizontal */, postprocessKeyStroke: _this.onPostprocessKeyStroke },
                    React.createElement("tr", { "aria-busy": ariaBusy, "aria-label": ariaLabel, "aria-rowindex": index + 1, "aria-selected": selection && selection.selected(index), className: css(_this.props.className, "bolt-table-row bolt-list-row", index === 0 && "first-row", focusStatus.hasFocus && "focused", selection && selection.selected(index) && "selected", singleClickActivation && "single-click-activation"), "data-focuszone": excludeFocusZone ? undefined : rowContext.focuszoneId, "data-row-index": _this.props.index, role: role, tabIndex: getTabIndex(details), onBlur: focusStatus.onBlur, onFocus: focusStatus.onFocus, ref: _this.rowElement },
                        React.createElement("td", { key: "left-spacer", className: "bolt-table-cell-compact bolt-table-cell bolt-list-cell bolt-table-spacer-cell", role: "presentation" }, renderSpacer && renderSpacer(index, true)),
                        _this.props.children,
                        React.createElement("td", { key: "right-spacer", className: "bolt-table-cell-compact bolt-table-cell bolt-list-cell bolt-table-spacer-cell", role: "presentation" }, renderSpacer && renderSpacer(index, false)))));
            }));
        }));
    };
    return TableRow;
}(React.Component));
export { TableRow };
export function TableCell(props) {
    var className = props.className, colspan = props.colspan, columnIndex = props.columnIndex, tableColumn = props.tableColumn;
    return (React.createElement("td", { key: "col-" + columnIndex, "aria-colindex": columnIndex, className: css(className, tableColumn && tableColumn.className, "bolt-table-cell bolt-list-cell"), colSpan: colspan, "data-column-index": columnIndex }, props.children));
}
export function SimpleTableCell(props) {
    var children = React.createElement("div", { className: css(props.contentClassName, "bolt-table-cell-content flex-row flex-center") }, props.children);
    return TableCell({
        children: children,
        className: props.className,
        colspan: props.colspan,
        columnIndex: props.columnIndex,
        tableColumn: props.tableColumn
    });
}
export function TwoLineTableCell(props) {
    var rowClasses = "bolt-table-two-line-cell-item flex-row scroll-hidden";
    var line1 = React.createElement("div", { className: rowClasses }, props.line1);
    var line2 = React.createElement("div", { className: rowClasses }, props.line2);
    var lines = (React.createElement(React.Fragment, null,
        line1,
        line2));
    var children;
    if (props.iconProps) {
        children = (React.createElement("div", { className: css(props.className, "bolt-table-cell-content flex-row flex-center") },
            Icon(tslib_1.__assign({}, props.iconProps, { className: css(props.iconProps.className, "bolt-table-two-line-cell-icon flex-noshrink") })),
            React.createElement("div", { className: "flex-column scroll-hidden" }, lines)));
    }
    else {
        children = React.createElement("div", { className: css(props.className, "bolt-table-cell-content flex-column") }, lines);
    }
    return TableCell({
        children: children,
        colspan: props.colspan,
        columnIndex: props.columnIndex,
        className: "bolt-table-two-line-cell",
        tableColumn: props.tableColumn
    });
}
export function renderEmptyCell(rowIndex, columnIndex) {
    return React.createElement(TableCell, { columnIndex: columnIndex, key: columnIndex });
}
/**
 * A basic cell renderer that works well for most simple columns. Gets the value of the
 * the {column.id} property in the given table item and displays it as a string
 *
 * @param rowIndex Index of the row being rendered
 * @param columnIndex Index of the column being rendered
 * @param tableColumn Column definition
 * @param tableItem The data item being rendered for the current row
 */
export function renderSimpleCell(rowIndex, columnIndex, tableColumn, tableItem) {
    return renderSimpleCellValue(columnIndex, tableColumn, tableItem[tableColumn.id]);
}
/**
 * Renders a simple table cell value
 *
 * @param columnIndex Index of the column being rendered
 * @param tableColumn Column definition
 * @param tableCell Simple value to render as text
 */
export function renderSimpleCellValue(columnIndex, tableColumn, tableCell) {
    var columnStyle = tableColumn.columnStyle;
    // Do not include padding if the table cell has an href
    var hasLink = !!(tableCell && typeof tableCell !== "string" && typeof tableCell !== "number" && tableCell.href);
    return (React.createElement(SimpleTableCell, { className: css(columnStyle === 2 /* Primary */ && "bolt-table-cell-primary", columnStyle === 1 /* Secondary */ && "bolt-table-cell-secondary", columnStyle === 3 /* Tertiary */ && "bolt-table-cell-tertiary"), columnIndex: columnIndex, contentClassName: hasLink ? "bolt-table-cell-content-with-link" : undefined, key: columnIndex, tableColumn: tableColumn }, tableCell && renderListCell(tableCell)));
}
function getVariableLength() {
    return Math.random() * 80 + 20 + "%";
}
export function renderLoadingCell(columnLayout) {
    if (columnLayout === 1 /* singleLine */ || columnLayout === undefined) {
        return (React.createElement("div", { className: "shimmer shimmer-line", style: { width: getVariableLength() } }, "\u00A0"));
    }
    else if (columnLayout === 2 /* singleLinePrefix */) {
        return (React.createElement(React.Fragment, null,
            React.createElement("div", { className: "shimmer shimmer-circle-small flex-noshrink" }),
            React.createElement("div", { className: "shimmer shimmer-line", style: { width: getVariableLength() } }, "\u00A0")));
    }
    else if (columnLayout === 3 /* twoLine */) {
        return (React.createElement("div", { className: "flex-column flex-grow" },
            React.createElement("div", { className: "bolt-table-two-line-cell-item shimmer shimmer-line", style: { width: getVariableLength() } }, "\u00A0"),
            React.createElement("div", { className: "bolt-table-two-line-cell-item shimmer shimmer-line", style: { width: getVariableLength() } }, "\u00A0")));
    }
    else if (columnLayout === 4 /* twoLinePrefix */) {
        return (React.createElement(React.Fragment, null,
            React.createElement("div", { className: "shimmer shimmer-circle-large flex-noshrink" }),
            React.createElement("div", { className: "flex-column flex-grow" },
                React.createElement("div", { className: "bolt-table-two-line-cell-item shimmer shimmer-line", style: { width: getVariableLength() } }, "\u00A0"),
                React.createElement("div", { className: "bolt-table-two-line-cell-item shimmer shimmer-line", style: { width: getVariableLength() } }, "\u00A0"))));
    }
    return null;
}
