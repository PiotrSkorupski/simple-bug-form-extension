import * as tslib_1 from "tslib";
import * as React from "react";
/**
 * An Observable implementation that will track a set of subscribers and supports
 * notifications when the underlying system changes.
 */
var Observable = /** @class */ (function () {
    function Observable() {
        this.observers = {};
        this.subscriberCount = 0;
    }
    /**
     * notify is used to send the event to all subscribers that have signed up for this events
     * action. This means they have subscribed directly to this action, or to all actions.
     * If the caller requested the event be persisted the event will be fired in order to new
     * subscribers as well when they subscribe.
     *
     * @param value - The object that represents the event data.
     *
     * @param action - The action that happened on this observable to produce the event.
     *
     * @param persistEvent - Optional value that determines if all future subscribers will
     *  recieve the event as well.
     */
    Observable.prototype.notify = function (value, action, persistEvent) {
        // NOTE: We need to make a copy of the observers since they may change during notification.
        if (this.observers[action]) {
            var observers = this.observers[action].slice();
            for (var observerIndex = 0; observerIndex < observers.length; observerIndex++) {
                observers[observerIndex](value, action);
            }
        }
        if (this.observers[""]) {
            var observers = this.observers[""].slice();
            for (var observerIndex = 0; observerIndex < observers.length; observerIndex++) {
                observers[observerIndex](value, action);
            }
        }
        // If the caller wants this event sent to all subscribers, event future ones, track it.
        if (persistEvent) {
            if (!this.events) {
                this.events = [];
            }
            this.events.push({ action: action, value: value });
        }
    };
    Observable.prototype.subscribe = function (observer, action) {
        action = action || "";
        if (!this.observers[action]) {
            this.observers[action] = [];
        }
        this.observers[action].push(observer);
        this.subscriberCount++;
        // Fire the callback for any events that were persisted when they were sent.
        if (this.events) {
            for (var _i = 0, _a = this.events; _i < _a.length; _i++) {
                var event_1 = _a[_i];
                if (!action || event_1.action === action) {
                    observer(event_1.value, event_1.action);
                }
            }
        }
    };
    Observable.prototype.unsubscribe = function (observer, action) {
        action = action || "";
        if (this.observers[action]) {
            var observerIndex = this.observers[action].indexOf(observer);
            if (observerIndex >= 0) {
                this.observers[action].splice(observerIndex, 1);
                this.subscriberCount--;
            }
        }
    };
    return Observable;
}());
export { Observable };
export var ObservableLike;
(function (ObservableLike) {
    /**
     * Check whether the specified object is an observable or not.
     *
     * @param observableLike Object to perform observable check.
     */
    function isObservable(observableLike) {
        return observableLike && typeof observableLike.subscribe === "function";
    }
    ObservableLike.isObservable = isObservable;
    function getValue(observableLike) {
        if (isObservable(observableLike)) {
            return observableLike.value;
        }
        return observableLike;
    }
    ObservableLike.getValue = getValue;
    /**
     * Subscribes to the specified object if it is an observable.
     *
     * @param observableLike Object to subscribe its value change if applicable.
     * @param observer Delegate to be executed when the underlying data changes.
     * @param action Optional argument that allows the consumer to supply a action
     *  with the delegate. If the action is supplied only those actions are delievered,
     *  while all actions are delivered is no action is supplied.
     */
    function subscribe(observableLike, observer, action) {
        if (isObservable(observableLike)) {
            observableLike.subscribe(observer, action);
        }
    }
    ObservableLike.subscribe = subscribe;
    /**
     * Unsubscribes from the specified object if it is an observable.
     *
     * @param observableLike Object to subscribe its value change if applicable.
     * @param observer Delegate to be executed when the underlying data changes.
     * @param action Optional argument that allows the consumer to supply a action
     *  with the delegate. If the action is supplied only those actions are delievered,
     *  while all actions are delivered is no action is supplied.
     */
    function unsubscribe(observableLike, observer, action) {
        if (isObservable(observableLike)) {
            observableLike.unsubscribe(observer, action);
        }
    }
    ObservableLike.unsubscribe = unsubscribe;
})(ObservableLike || (ObservableLike = {}));
var ObservableValue = /** @class */ (function (_super) {
    tslib_1.__extends(ObservableValue, _super);
    function ObservableValue(value) {
        var _this = _super.call(this) || this;
        _this.v = value;
        return _this;
    }
    Object.defineProperty(ObservableValue.prototype, "value", {
        get: function () {
            return this.v;
        },
        set: function (value) {
            this.v = value;
            this.notify(this.v, "set");
        },
        enumerable: true,
        configurable: true
    });
    return ObservableValue;
}(Observable));
export { ObservableValue };
/**
 * An ObservableObject can be used to key a named collection of properties
 * and offer an observable endpoint.
 */
var ObservableObject = /** @class */ (function (_super) {
    tslib_1.__extends(ObservableObject, _super);
    function ObservableObject() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.objects = {};
        return _this;
    }
    ObservableObject.prototype.add = function (objectName, objectDefinition) {
        if (!this.objects.hasOwnProperty(objectName)) {
            this.objects[objectName] = objectDefinition;
            this.notify({ key: objectName, value: objectDefinition }, "add");
        }
    };
    ObservableObject.prototype.get = function (objectName) {
        return this.objects[objectName];
    };
    ObservableObject.prototype.keys = function () {
        return Object.keys(this.objects);
    };
    return ObservableObject;
}(Observable));
export { ObservableObject };
/**
 * EventTypes:
 *  change - { changedItems, index }
 *  push - {addedItems, index }
 *  pop - { index, removedItems}
 *  removeAll - {index, removedItems }
 *  splice - { addedItems, index, removedItems }
 */
var ObservableArray = /** @class */ (function (_super) {
    tslib_1.__extends(ObservableArray, _super);
    function ObservableArray(items) {
        if (items === void 0) { items = []; }
        var _this = _super.call(this) || this;
        _this.internalItems = items || [];
        return _this;
    }
    ObservableArray.prototype.change = function (start) {
        var _a;
        var items = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            items[_i - 1] = arguments[_i];
        }
        (_a = this.internalItems).splice.apply(_a, [start, items.length].concat(items));
        this.notify({ index: start, changedItems: items }, "change");
        return items.length;
    };
    Object.defineProperty(ObservableArray.prototype, "length", {
        get: function () {
            return this.internalItems.length;
        },
        enumerable: true,
        configurable: true
    });
    ObservableArray.prototype.push = function () {
        var _a;
        var items = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            items[_i] = arguments[_i];
        }
        if (items.length) {
            var index = this.internalItems.length;
            (_a = this.internalItems).push.apply(_a, items);
            this.notify({ addedItems: items, index: index }, "push");
        }
        return items.length;
    };
    ObservableArray.prototype.pop = function () {
        var item = this.internalItems.pop();
        if (item !== undefined) {
            this.notify({ index: 0, removedItems: [item] }, "pop");
        }
        return item;
    };
    ObservableArray.prototype.removeAll = function (filter) {
        var removedItems = [];
        var remainingItems = [];
        for (var _i = 0, _a = this.internalItems; _i < _a.length; _i++) {
            var item = _a[_i];
            if (!filter || filter(item)) {
                removedItems.push(item);
            }
            else {
                remainingItems.push(item);
            }
        }
        if (removedItems.length > 0) {
            this.internalItems = remainingItems;
            this.notify({ index: 0, removedItems: removedItems }, "removeAll");
        }
        return removedItems;
    };
    ObservableArray.prototype.splice = function (start, deleteCount) {
        var _a;
        var itemsToAdd = [];
        for (var _i = 2; _i < arguments.length; _i++) {
            itemsToAdd[_i - 2] = arguments[_i];
        }
        var removedItems = (_a = this.internalItems).splice.apply(_a, [start, deleteCount].concat(itemsToAdd));
        this.notify({ addedItems: itemsToAdd, index: start, removedItems: removedItems }, "splice");
        return removedItems;
    };
    Object.defineProperty(ObservableArray.prototype, "value", {
        get: function () {
            return this.internalItems;
        },
        set: function (items) {
            this.splice.apply(this, [0, this.length].concat(items));
        },
        enumerable: true,
        configurable: true
    });
    return ObservableArray;
}(Observable));
export { ObservableArray };
/**
 * An Observable Collection takes an arry of arrays or observable arrays
 * and flattens out the items into a single readonly observable array
 * (with all the underlying array values aggregated together).
 *
 * This handles subscribing to any underlying observable arrays and
 * updating the aggregate array as appropriate (and notifying subscribers)
 */
var ObservableCollection = /** @class */ (function (_super) {
    tslib_1.__extends(ObservableCollection, _super);
    function ObservableCollection() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.collections = [];
        _this.items = [];
        return _this;
    }
    Object.defineProperty(ObservableCollection.prototype, "length", {
        get: function () {
            return this.items.length;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ObservableCollection.prototype, "value", {
        get: function () {
            return this.items;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Adds an additional collection of items to the end of the array
     *
     * @param collection Array of items or an observable array of items
     * @params transformItems Delegate to process each item that is pulled from the given collection
     */
    ObservableCollection.prototype.push = function (collection, transformItems) {
        var _a;
        var collectionEntry;
        if (ObservableLike.isObservable(collection)) {
            var observable = collection;
            var subscriber = this.getSubscriber(this.collections.length, transformItems);
            collectionEntry = { items: observable.value, observable: observable, subscriber: subscriber };
            if (this.subscriberCount) {
                ObservableLike.subscribe(collectionEntry.observable, subscriber);
            }
        }
        else if (collection.length) {
            collectionEntry = { items: collection };
        }
        if (collectionEntry) {
            this.collections.push(collectionEntry);
            if (collectionEntry.items.length) {
                var newItems = this.transformItems(collectionEntry.items, transformItems);
                (_a = this.items).push.apply(_a, newItems);
                if (this.subscriberCount) {
                    this.notify({ addedItems: newItems, index: this.items.length - newItems.length }, "push");
                }
            }
        }
    };
    ObservableCollection.prototype.subscribe = function (observer, action) {
        _super.prototype.subscribe.call(this, observer, action);
        if (this.subscriberCount === 1) {
            for (var _i = 0, _a = this.collections; _i < _a.length; _i++) {
                var collection = _a[_i];
                if (collection.subscriber) {
                    collection.observable.subscribe(collection.subscriber);
                }
            }
        }
    };
    ObservableCollection.prototype.unsubscribe = function (observer, action) {
        _super.prototype.unsubscribe.call(this, observer, action);
        if (this.subscriberCount === 0) {
            for (var _i = 0, _a = this.collections; _i < _a.length; _i++) {
                var collection = _a[_i];
                if (collection.subscriber) {
                    collection.observable.unsubscribe(collection.subscriber);
                }
            }
        }
    };
    ObservableCollection.prototype.transformItems = function (inputItems, transformInput) {
        var transformedItems;
        if (!inputItems) {
            transformedItems = [];
        }
        else if (transformInput) {
            transformedItems = [];
            for (var _i = 0, inputItems_1 = inputItems; _i < inputItems_1.length; _i++) {
                var inputItem = inputItems_1[_i];
                var transformedItem = transformInput(inputItem);
                if (transformedItem !== undefined) {
                    transformedItems.push(transformedItem);
                }
            }
        }
        else {
            transformedItems = inputItems;
        }
        return transformedItems;
    };
    ObservableCollection.prototype.getSubscriber = function (collectionIndex, transformInput) {
        var _this = this;
        return function (args) {
            var _a, _b;
            // Find the index in our aggregate array
            var index = args.index;
            for (var i = 0; i < collectionIndex; i++) {
                index += _this.collections[collectionIndex].items.length;
            }
            if (args.changedItems) {
                // Handle change event
                var changedItems = _this.transformItems(args.changedItems, transformInput);
                (_a = _this.items).splice.apply(_a, [index, args.changedItems.length].concat(changedItems));
                _this.notify({ changedItems: changedItems, index: index }, "change");
            }
            else {
                // Handle splice, push, pop events
                var removedItems = _this.transformItems(args.removedItems, transformInput);
                var addedItems = _this.transformItems(args.addedItems, transformInput);
                (_b = _this.items).splice.apply(_b, [index, removedItems.length].concat(addedItems));
                _this.notify({ removedItems: removedItems, addedItems: addedItems, index: index }, "splice");
            }
        };
    };
    return ObservableCollection;
}(Observable));
export { ObservableCollection };
var ReadyableObservableArray = /** @class */ (function (_super) {
    tslib_1.__extends(ReadyableObservableArray, _super);
    function ReadyableObservableArray() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.ready = new ObservableValue(false);
        return _this;
    }
    return ReadyableObservableArray;
}(ObservableArray));
export { ReadyableObservableArray };
/**
 * React Hooks extension that allows the consmer to track Observables with a useState like
 * hooks API.
 *
 * @param initialState Initial value for the state, or a function that will resolve the value
 * the when the value is initialized.
 */
export function useObservable(initialState) {
    var underlyingState = React.useState(initialState)[0];
    var reactState = React.useState(new ObservableValue(underlyingState));
    var updateState = function (updatedState) {
        if (typeof updatedState === "function") {
            reactState[0].value = updatedState(reactState[0].value);
        }
        else {
            reactState[0].value = updatedState;
        }
    };
    return [reactState[0], updateState];
}
/**
 * React Hooks extension that allows the consmer to track ObservableArrays with a useState like
 * hooks API.
 *
 * @param initialState Initial value for the state, or a function that will resolve the value
 * the when the value is initialized.
 */
export function useObservableArray(initialState) {
    var underlyingState = React.useState(initialState)[0];
    var reactState = React.useState(new ObservableArray(underlyingState));
    var updateState = function (updatedState) {
        if (typeof updatedState === "function") {
            reactState[0].value = updatedState(reactState[0].value);
        }
        else {
            reactState[0].value = updatedState;
        }
    };
    return [reactState[0], updateState];
}
